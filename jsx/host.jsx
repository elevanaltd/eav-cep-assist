// ExtendScript for Premiere Pro

// Handles communication between the CEP panel and Premiere Pro



var EAVIngest = (function() {

  'use strict';



  /**

     * Log to file for debugging (when console not available)

     */

  function _logToFile(message) {

    try {

      // Use user data directory instead of desktop for privacy
      // Creates ~/.debug/ directory if it doesn't exist
      var debugDir = new Folder(Folder.userData.parent.fsName + '/.debug');
      if (!debugDir.exists) {
        debugDir.create();
      }

      var logFile = new File(debugDir.fsName + '/eav-cep-debug.txt');

      logFile.open('a'); // append mode

      logFile.writeln(new Date().toISOString() + ' - ' + message);

      logFile.close();

    } catch (e) {

      // Silently fail if file write errors

    }

    // Also write to console (if available)

    $.writeln(message);

  }



  /**

     * Escape XML entities to prevent injection attacks

     * @param {string} str - Raw string value

     * @returns {string} XML-safe escaped string

     */

  function escapeXML(str) {

    if (!str) {return '';}

    return String(str)

      .replace(/&/g, '&amp;')

      .replace(/</g, '&lt;')

      .replace(/>/g, '&gt;')

      .replace(/"/g, '&quot;')

      .replace(/'/g, '&apos;');

  }



  /**

     * Get currently selected project item(s) from Project Panel

     * Returns array of selected clips with their metadata

     */

  function getSelectedClips() {

    var project = app.project;

    if (!project) {

      return JSON.stringify({ error: 'No active project' });

    }



    var selection = project.getSelection();

    if (!selection || selection.length === 0) {

      return JSON.stringify({ error: 'No clips selected' });

    }



    var clips = [];

    for (var i = 0; i < selection.length; i++) {

      var item = selection[i];



      // Only process video/image items, not bins

      if (item.type === ProjectItemType.CLIP || item.type === ProjectItemType.FILE) {

        // DIAGNOSTIC: Test Project Columns access in getSelectedClips() context
        /** @type {*} */
        var projectCols = item.getProjectColumnsMetadata();
        var colTest = 'Tape=' + (projectCols.Tape || 'NONE') +
                      ' | Desc=' + (projectCols.Description || 'NONE') +
                      ' | Shot=' + (projectCols.Shot || 'NONE') +
                      ' | LogComment(space)=' + (projectCols['Log Comment'] || 'NONE') +
                      ' | LogComment(noSpace)=' + (projectCols.LogComment || 'NONE');
        $.writeln('DEBUG getSelectedClips() PROJECT COLUMNS: ' + colTest);

        clips.push({

          nodeId: item.nodeId,

          name: item.name || '',

          treePath: item.treePath || '',

          mediaPath: item.getMediaPath() || '',

          // Get existing metadata from PP fields

          tapeName: projectCols.Tape || '',

          description: projectCols.Description || '',

          shot: projectCols.Shot || '',

          // DIAGNOSTIC: Test if we can read Log Comment
          logCommentFromColumn: projectCols['Log Comment'] || projectCols.LogComment || 'NO_COLUMN_ACCESS',

          // File info

          videoFrameRate: item.getFootageInterpretation().frameRate || '',

          duration: item.getOutPoint().seconds || 0,

          type: item.type

        });

      }

    }



    if (clips.length === 0) {

      return JSON.stringify({ error: 'No video/image clips in selection' });

    }



    return JSON.stringify({ clips: clips });

  }



  // ============================================================================
  // TRACK A: JSON SIDECAR INTEGRATION
  // ============================================================================
  //
  // Source: src/track-a/json-integration.js (ES6)
  // Transpiled: jsx/generated/track-a-integration.jsx (ES3)
  // Build: npm run build
  //
  // This file is auto-generated from src/track-a/json-integration.js
  // DO NOT EDIT THIS FILE DIRECTLY - edit the source and run npm run build
  //
  // Functions:
  // - computeShotName(metadata)
  // - readJSONFromFile(jsonFile, clipName, $)
  // - readJSONMetadata(clip, FileConstructor, $)
  // - writeJSONToFile(jsonFile, clipName, updates, $)
  // - writeJSONMetadata(clip, updates, FileConstructor, $)
  // - readJSONMetadataByNodeId(nodeId, app, findProjectItemByNodeId, FileConstructor, $)
  // - writeJSONMetadataByNodeId(nodeId, updatesJSON, app, findProjectItemByNodeId, FileConstructor, $)
  //
  // ============================================================================

  // @include "generated/track-a-integration.jsx"
  
  // Track A wrapper function declarations (defined in generated/track-a-integration.jsx)
  // @ts-ignore - Functions are included via @include directive
  var readJSONMetadataWrapper, writeJSONMetadataWrapper;
  // @ts-ignore - Functions are included via @include directive
  var readJSONMetadataByNodeIdWrapper, writeJSONMetadataByNodeIdWrapper;





  /**

     * Update PP project item metadata fields

     * Updates: Name, Tape Name, Description, Shot

     */

  function updateClipMetadata(nodeId, metadata) {

    var debugLog = []; // Collect debug messages to return to CEP panel

    var project = app.project;

    if (!project) {

      return JSON.stringify({ success: false, error: 'No active project' });

    }



    // Find the project item by nodeId

    var item = findProjectItemByNodeId(project.rootItem, nodeId);

    if (!item) {

      return JSON.stringify({ success: false, error: 'Clip not found' });

    }



    try {

      // Update Name field (visible in Project Panel)

      if (metadata.name !== undefined) {

        item.name = metadata.name;

      }



      // Update metadata via XMP

      try {

        var xmpString = item.getXMPMetadata();

        debugLog.push('Got XMP (length: ' + xmpString.length + ')');

        debugLog.push('Incoming metadata:');

        debugLog.push('  description: \'' + metadata.description + '\'');

        debugLog.push('  location: \'' + metadata.location + '\'');

        debugLog.push('  subject: \'' + metadata.subject + '\'');

        debugLog.push('  action: \'' + metadata.action + '\'');

        debugLog.push('  shot: \'' + metadata.shot + '\'');



        // ========== DUBLIN CORE NAMESPACE FIELDS ==========

        // Collect all Dublin Core fields to update

        var dcFields = [];

        if (metadata.description !== undefined) {

          dcFields.push({

            tag: 'dc:description',

            value: '<dc:description><rdf:Alt><rdf:li xml:lang="x-default">' + escapeXML(metadata.description) + '</rdf:li></rdf:Alt></dc:description>',

            regex: /<dc:description[^>]*>[\s\S]*?<\/dc:description>/

          });

        }

        if (metadata.identifier !== undefined) {

          dcFields.push({

            tag: 'dc:identifier',

            value: '<dc:identifier>' + escapeXML(metadata.identifier) + '</dc:identifier>',

            regex: /<dc:identifier[^>]*>[\s\S]*?<\/dc:identifier>/

          });

        }



        // Update Dublin Core fields in their namespace block

        if (dcFields.length > 0) {

          // Find the Dublin Core rdf:Description block

          var dcBlockMatch = xmpString.match(/<rdf:Description[^>]*xmlns:dc="http:\/\/purl\.org\/dc\/elements\/1\.1\/"[^>]*>([\s\S]*?)<\/rdf:Description>/);



          if (dcBlockMatch) {

            // DC block exists - update fields within it

            var dcBlockContent = dcBlockMatch[1];

            var dcBlockFull = dcBlockMatch[0];



            for (var i = 0; i < dcFields.length; i++) {

              var field = dcFields[i];

              if (dcBlockContent.indexOf('<' + field.tag) > -1) {

                // Field exists - replace it

                debugLog.push(field.tag + ' FOUND, replacing...');

                var beforeReplace = dcBlockContent;

                dcBlockContent = dcBlockContent.replace(field.regex, field.value);

                if (beforeReplace === dcBlockContent) {

                  debugLog.push('ERROR: ' + field.tag + ' regex did NOT match!');

                } else {

                  debugLog.push(field.tag + ' successfully replaced');

                }

              } else {

                // Field doesn't exist - append it

                debugLog.push(field.tag + ' NOT FOUND, appending...');

                dcBlockContent += field.value;

              }

              debugLog.push(field.tag + ' updated');

            }



            // Replace the entire DC block with updated content

            // Extract just the opening tag (everything up to first '>')

            var openingTagEnd = dcBlockFull.indexOf('>') + 1;

            var openingTag = dcBlockFull.substring(0, openingTagEnd);

            var newDcBlock = openingTag + dcBlockContent + '</rdf:Description>';

            xmpString = xmpString.replace(dcBlockFull, newDcBlock);



          } else {

            // DC block doesn't exist - create it

            var dcBlock = '<rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">';

            for (var i = 0; i < dcFields.length; i++) {

              dcBlock += dcFields[i].value;

              $.writeln('DEBUG SAVE: ' + dcFields[i].tag + ' created');

            }

            dcBlock += '</rdf:Description>';



            // Insert before closing </rdf:RDF>

            xmpString = xmpString.replace(/<\/rdf:RDF>/, dcBlock + '</rdf:RDF>');

          }

        }



        // ========== XMPDM NAMESPACE FIELDS (IA COMPATIBILITY) ==========

        // Build combined shotName and structured LogComment

        var xmpDmFields = [];



        // Build shotName: location-subject-action-shotType (or without action for images)

        if (metadata.location && metadata.subject && metadata.shot) {

          var shotName = metadata.location + '-' + metadata.subject;

          if (metadata.action) {

            shotName += '-' + metadata.action;

          }

          shotName += '-' + metadata.shot;



          xmpDmFields.push({

            tag: 'xmpDM:shotName',

            value: '<xmpDM:shotName>' + escapeXML(shotName) + '</xmpDM:shotName>',

            regex: /<xmpDM:shotName[^>]*>[\s\S]*?<\/xmpDM:shotName>/

          });

        }



        // Build LogComment: location=X, subject=Y, action=Z, shotType=W

        if (metadata.location !== undefined && metadata.subject !== undefined && metadata.shot !== undefined) {

          var logComment = 'location=' + escapeXML(metadata.location || '') +

                                   ', subject=' + escapeXML(metadata.subject || '') +

                                   ', action=' + escapeXML(metadata.action || '') +

                                   ', shotType=' + escapeXML(metadata.shot || '');



          xmpDmFields.push({

            tag: 'xmpDM:LogComment',

            value: '<xmpDM:LogComment>' + logComment + '</xmpDM:LogComment>',

            regex: /<xmpDM:LogComment[^>]*>[\s\S]*?<\/xmpDM:LogComment>/

          });

        }



        // Update xmpDM fields in their namespace block

        if (xmpDmFields.length > 0) {

          // Find the xmpDM rdf:Description block

          var xmpDmBlockMatch = xmpString.match(/<rdf:Description[^>]*xmlns:xmpDM="http:\/\/ns\.adobe\.com\/xmp\/1\.0\/DynamicMedia\/"[^>]*>([\s\S]*?)<\/rdf:Description>/);



          if (xmpDmBlockMatch) {

            // xmpDM block exists - update fields within it

            var xmpDmBlockContent = xmpDmBlockMatch[1];

            var xmpDmBlockFull = xmpDmBlockMatch[0];



            for (var i = 0; i < xmpDmFields.length; i++) {

              var field = xmpDmFields[i];

              if (xmpDmBlockContent.indexOf('<' + field.tag) > -1) {

                // Field exists - replace it

                debugLog.push(field.tag + ' FOUND, replacing...');

                var beforeReplace = xmpDmBlockContent;

                xmpDmBlockContent = xmpDmBlockContent.replace(field.regex, field.value);

                if (beforeReplace === xmpDmBlockContent) {

                  debugLog.push('ERROR: ' + field.tag + ' regex did NOT match!');

                } else {

                  debugLog.push(field.tag + ' successfully replaced');

                }

              } else {

                // Field doesn't exist - append it

                debugLog.push(field.tag + ' NOT FOUND, appending...');

                xmpDmBlockContent += field.value;

              }

              debugLog.push(field.tag + ' updated');

            }



            // Replace the entire xmpDm block with updated content

            // Extract just the opening tag (everything up to first '>')

            var openingTagEnd = xmpDmBlockFull.indexOf('>') + 1;

            var openingTag = xmpDmBlockFull.substring(0, openingTagEnd);

            var newXmpDmBlock = openingTag + xmpDmBlockContent + '</rdf:Description>';

            xmpString = xmpString.replace(xmpDmBlockFull, newXmpDmBlock);



          } else {

            // xmpDm block doesn't exist - create it

            var xmpDmBlock = '<rdf:Description rdf:about="" xmlns:xmpDM="http://ns.adobe.com/xmp/1.0/DynamicMedia/">';

            for (var i = 0; i < xmpDmFields.length; i++) {

              xmpDmBlock += xmpDmFields[i].value;

              $.writeln('DEBUG SAVE: ' + xmpDmFields[i].tag + ' created');

            }

            xmpDmBlock += '</rdf:Description>';



            // Insert before closing </rdf:RDF>

            xmpString = xmpString.replace(/<\/rdf:RDF>/, xmpDmBlock + '</rdf:RDF>');

          }

        }



        item.setXMPMetadata(xmpString);

        debugLog.push('XMP metadata updated successfully');



      } catch (xmpError) {

        debugLog.push('XMP ERROR: ' + xmpError.toString());

      }



      // ========== WRITE PP EDITS JSON ==========

      // Write PP edits to original folder for ML feedback loop

      try {

        var mediaPath = item.getMediaPath();

        if (mediaPath) {

          // Extract directory and filename

          var lastSlash = mediaPath.lastIndexOf('/');

          var dirPath = mediaPath.substring(0, lastSlash);

          var filename = mediaPath.substring(lastSlash + 1);

          var filenameNoExt = filename.replace(/\.[^.]+$/, '');



          // Read existing .ingest-metadata.json (if exists)

          var iaJsonPath = dirPath + '/.ingest-metadata.json';

          var iaJsonFile = new File(iaJsonPath);

          var iaData = {};

          if (iaJsonFile.exists) {

            iaJsonFile.open('r');

            var iaJsonContent = iaJsonFile.read();

            iaJsonFile.close();

            try {

              iaData = JSON.parse(iaJsonContent);

            } catch (_parseError) {

              debugLog.push('Warning: Could not parse existing IA JSON');

            }

          }



          // Build PP edits entry (matches IA format)

          var fileId = metadata.identifier ? metadata.identifier.replace(/\.[^.]+$/, '') : filenameNoExt;

          var iaEntry = iaData[fileId] || {};



          var ppEditsEntry = {};

          ppEditsEntry[fileId] = {

            // File Identification (preserve from IA)

            id: fileId,

            originalFilename: iaEntry.originalFilename || filename,

            currentFilename: filename,

            filePath: mediaPath,

            extension: iaEntry.extension || filename.substring(filename.lastIndexOf('.')),

            fileType: iaEntry.fileType || 'video',



            // Core Metadata (from PP edits)

            mainName: metadata.location + '-' + metadata.subject + (metadata.action ? '-' + metadata.action : '') + '-' + metadata.shot,

            keywords: metadata.description ? metadata.description.split(',').map(function(k) { return k.replace(/^\s+|\s+$/g, ''); }) : [],



            // Structured Components

            location: metadata.location || '',

            subject: metadata.subject || '',

            action: metadata.action || '',

            shotType: metadata.shot || '',



            // Processing State (preserve from IA)

            processedByAI: iaEntry.processedByAI || false,



            // Audit Trail

            createdAt: iaEntry.createdAt || new Date().toISOString(),

            createdBy: iaEntry.createdBy || 'unknown',

            modifiedAt: new Date().toISOString(),

            modifiedBy: 'cep-panel',

            version: '1.0.0'

          };



          // Write to .ingest-metadata-pp.json

          var ppJsonPath = dirPath + '/.ingest-metadata-pp.json';

          var ppJsonFile = new File(ppJsonPath);



          // Read existing PP edits (if any)

          var existingPpData = { _schema: '2.0' };

          if (ppJsonFile.exists) {

            ppJsonFile.open('r');

            var existingContent = ppJsonFile.read();

            ppJsonFile.close();

            try {

              existingPpData = JSON.parse(existingContent);

            } catch (e) {

              existingPpData = { _schema: '2.0' };

            }

          }



          // Merge this entry

          existingPpData[fileId] = ppEditsEntry[fileId];



          // Write back

          ppJsonFile.open('w');

          ppJsonFile.write(JSON.stringify(existingPpData, null, 2));

          ppJsonFile.close();



          debugLog.push('PP edits JSON written: ' + ppJsonPath);

        } else {

          debugLog.push('Warning: No media path, skipping PP edits JSON');

        }

      } catch (jsonError) {

        debugLog.push('PP edits JSON error: ' + jsonError.toString());

      }



      return JSON.stringify({

        success: true,

        updatedName: item.name,

        debug: debugLog

      });

    } catch (e) {

      return JSON.stringify({

        success: false,

        error: 'Failed to update metadata: ' + e.toString()

      });

    }

  }



  /**

     * Helper: Find project item by nodeId (recursive search)

     */

  function findProjectItemByNodeId(parentItem, nodeId) {

    if (parentItem.nodeId === nodeId) {

      return parentItem;

    }



    // Search children recursively

    if (parentItem.children && parentItem.children.numItems > 0) {

      for (var i = 0; i < parentItem.children.numItems; i++) {

        var found = findProjectItemByNodeId(parentItem.children[i], nodeId);

        if (found) {

          return found;

        }

      }

    }



    return null;

  }



  /**

     * Get all clips in the project (for navigation)

     */

  function getAllProjectClips() {

    try {

      var project = app.project;

      if (!project) {

        return JSON.stringify({ error: 'No active project' });

      }



      var clips = [];

      collectClipsRecursive(project.rootItem, clips);



      // Convert clips to JSON-friendly objects (ES3-compatible, no .map())

      var clipsData = [];

      for (var i = 0; i < clips.length; i++) {

        var item = clips[i];



        // Safely get metadata with try-catch per item

        var metadata = {};

        // DIAGNOSTIC: Test direct access to known Project Column names
        try {

          var projectCols = item.getProjectColumnsMetadata();

          // Try direct access to known columns
          var directAccess = [];

          if (projectCols.Tape !== undefined) {
            directAccess.push('Tape=' + projectCols.Tape);
          }

          if (projectCols.Description !== undefined) {
            directAccess.push('Desc=' + projectCols.Description);
          }

          if (projectCols.Shot !== undefined) {
            directAccess.push('Shot=' + projectCols.Shot);
          }

          // Try "Log Comment" with different variations
          if (projectCols['Log Comment'] !== undefined) {
            directAccess.push('LogComment(space)=' + projectCols['Log Comment']);
          }

          if (projectCols.LogComment !== undefined) {
            directAccess.push('LogComment(noSpace)=' + projectCols.LogComment);
          }

          if (projectCols.Comment !== undefined) {
            directAccess.push('Comment=' + projectCols.Comment);
          }

          if (projectCols['Shot Name'] !== undefined) {
            directAccess.push('ShotName(space)=' + projectCols['Shot Name']);
          }

          metadata.availableColumns = directAccess.length > 0 ? directAccess.join(' | ') : 'NO_DIRECT_ACCESS';

          $.writeln('DEBUG PROJECT COLUMNS DIRECT ACCESS: ' + metadata.availableColumns);

        } catch (colError) {

          metadata.availableColumns = 'ERROR: ' + colError.toString();

        }

        // Try reading from XMP metadata instead of Project Columns

        try {

          var xmpString = item.getXMPMetadata();

          $.writeln('DEBUG: Got XMP metadata (length: ' + xmpString.length + ')');

          // DIAGNOSTIC: Show snippet of XMP to debug console
          var xmpSnippet = xmpString.substring(0, 500);
          $.writeln('DEBUG XMP SNIPPET: ' + xmpSnippet);

          // DIAGNOSTIC: Pass XMP snippet to CEP panel diagnostics (since console doesn't work)
          metadata.xmpSnippet = xmpSnippet;

          // DIAGNOSTIC: Search for LogComment anywhere in XMP (case-insensitive)
          var logCommentIndex = xmpString.toLowerCase().indexOf('logcomment');
          if (logCommentIndex !== -1) {
            // Found it! Extract 200 chars around it for debugging
            var start = Math.max(0, logCommentIndex - 50);
            var end = Math.min(xmpString.length, logCommentIndex + 150);
            metadata.logCommentContext = xmpString.substring(start, end);
          } else {
            metadata.logCommentContext = 'NOT_FOUND_IN_XMP_STRING';
          }

          // Parse XMP for Dublin Core description

          var descMatch = xmpString.match(/<dc:description[^>]*>[\s\S]*?<rdf:li[^>]*>(.*?)<\/rdf:li>/);

          if (descMatch) {

            metadata.description = descMatch[1] || '';

            $.writeln('DEBUG: Found description in XMP: \'' + metadata.description + '\'');

          } else {

            metadata.description = '';

            $.writeln('DEBUG: No description found in XMP');

          }



          // Parse Dublin Core identifier (standard XMP field)

          var identifierMatch = xmpString.match(/<dc:identifier>(.*?)<\/dc:identifier>/);

          metadata.identifier = (identifierMatch && identifierMatch[1]) ? identifierMatch[1] : '';

          $.writeln('DEBUG: Found identifier in XMP: \'' + metadata.identifier + '\'');



          // Parse xmpDM:logComment for structured components (IA compatibility)
          // NOTE: Premiere Pro returns XMP as ELEMENTS, and IA writes lowercase 'logComment'
          var logCommentMatch = xmpString.match(/<xmpDM:logComment>(.*?)<\/xmpDM:logComment>/);
          metadata.regexAttempt = 'lowercase-c-element'; // DIAGNOSTIC
          if (!logCommentMatch) {
            // Fallback: Try capital C for CEP Panel-written XMP
            $.writeln('DEBUG: logComment (lowercase c) not found, trying capital C...');
            logCommentMatch = xmpString.match(/<xmpDM:LogComment>(.*?)<\/xmpDM:LogComment>/);
            metadata.regexAttempt = 'capital-C-element'; // DIAGNOSTIC
          }

          if (logCommentMatch) {

            var logComment = logCommentMatch[1];

            $.writeln('DEBUG: Found LogComment: \'' + logComment + '\'');

            // DIAGNOSTIC: Return raw logComment so it shows in CEP diagnostic panel
            metadata.rawLogComment = logComment;
            metadata.regexAttempt = metadata.regexAttempt + '-MATCHED'; // DIAGNOSTIC

            // Parse location=X, subject=Y, action=Z, shotType=W

            var locationMatch = logComment.match(/location=([^,]*)/);

            metadata.location = (locationMatch && locationMatch[1]) ? locationMatch[1].replace(/^\s+|\s+$/g, '') : '';



            var subjectMatch = logComment.match(/subject=([^,]*)/);

            metadata.subject = (subjectMatch && subjectMatch[1]) ? subjectMatch[1].replace(/^\s+|\s+$/g, '') : '';



            var actionMatch = logComment.match(/action=([^,]*)/);

            metadata.action = (actionMatch && actionMatch[1]) ? actionMatch[1].replace(/^\s+|\s+$/g, '') : '';



            var shotTypeMatch = logComment.match(/shotType=([^,]*)/);

            metadata.shot = (shotTypeMatch && shotTypeMatch[1]) ? shotTypeMatch[1].replace(/^\s+|\s+$/g, '') : '';

          } else {

            // Fallback: Try legacy individual XMP fields for backward compatibility

            $.writeln('DEBUG: LogComment not found, using legacy XMP fields');
            // DIAGNOSTIC: Show we didn't find it
            metadata.rawLogComment = 'NOT_FOUND_IN_XMP';
            metadata.regexAttempt = metadata.regexAttempt + '-NO_MATCH'; // DIAGNOSTIC



            var shotMatch = xmpString.match(/<xmp:Shot>(.*?)<\/xmp:Shot>/);

            metadata.shot = (shotMatch && shotMatch[1]) ? shotMatch[1] : '';



            var locationMatch = xmpString.match(/<xmp:Location>(.*?)<\/xmp:Location>/);

            metadata.location = (locationMatch && locationMatch[1]) ? locationMatch[1] : '';



            var subjectMatch = xmpString.match(/<xmp:Subject>(.*?)<\/xmp:Subject>/);

            metadata.subject = (subjectMatch && subjectMatch[1]) ? subjectMatch[1] : '';



            var actionMatch = xmpString.match(/<xmp:Action>(.*?)<\/xmp:Action>/);

            metadata.action = (actionMatch && actionMatch[1]) ? actionMatch[1] : '';

          }



          var sceneMatch = xmpString.match(/<xmp:Scene>(.*?)<\/xmp:Scene>/);

          metadata.good = (sceneMatch && sceneMatch[1]) ? sceneMatch[1] : '';



          $.writeln('DEBUG FINAL XMP VALUES for ' + item.name + ':');

          $.writeln('  identifier: \'' + metadata.identifier + '\'');

          $.writeln('  description: \'' + metadata.description + '\'');

          $.writeln('  shot: \'' + metadata.shot + '\'');

          $.writeln('  good: \'' + metadata.good + '\'');

          $.writeln('  location: \'' + metadata.location + '\'');

          $.writeln('  subject: \'' + metadata.subject + '\'');

          $.writeln('  action: \'' + metadata.action + '\'');



        } catch (xmpError) {

          $.writeln('DEBUG XMP ERROR: ' + xmpError.toString());

          // DIAGNOSTIC: Pass error to CEP panel diagnostics
          metadata.xmpSnippet = 'ERROR: ' + xmpError.toString();
          metadata.regexAttempt = 'ERROR_BEFORE_REGEX';
          metadata.rawLogComment = 'ERROR: ' + xmpError.toString();
          metadata.logCommentContext = 'ERROR: ' + xmpError.toString();

          metadata.identifier = '';

          metadata.description = '';

          metadata.shot = '';

          metadata.good = '';

          metadata.location = '';

          metadata.subject = '';

          metadata.action = '';

        }



        clipsData.push({

          nodeId: item.nodeId,

          name: item.name || '',

          treePath: item.treePath || '',

          mediaPath: item.getMediaPath() || '',

          identifier: metadata.identifier,

          description: metadata.description,

          shot: metadata.shot,

          good: metadata.good,

          location: metadata.location,

          subject: metadata.subject,

          action: metadata.action,

          // DIAGNOSTIC fields for debugging
          rawLogComment: metadata.rawLogComment || 'NOT_SET',

          regexAttempt: metadata.regexAttempt || 'NOT_SET',

          xmpSnippet: metadata.xmpSnippet || 'NOT_SET',

          logCommentContext: metadata.logCommentContext || 'NOT_SET',

          availableColumns: metadata.availableColumns || 'NOT_SET'

        });

      }



      return JSON.stringify({ clips: clipsData });

    } catch (e) {

      return JSON.stringify({

        error: 'getAllProjectClips failed',

        details: e.toString(),

        message: e.message || 'Unknown error'

      });

    }

  }



  /**

     * Helper: Recursively collect all clips from project

     */

  function collectClipsRecursive(parentItem, clips) {

    // Add current item if it's a clip

    if (parentItem.type === ProjectItemType.CLIP || parentItem.type === ProjectItemType.FILE) {

      clips.push(parentItem);

    }



    // Recurse into children

    if (parentItem.children && parentItem.children.numItems > 0) {

      for (var i = 0; i < parentItem.children.numItems; i++) {

        collectClipsRecursive(parentItem.children[i], clips);

      }

    }

  }



  /**

     * Select a specific clip in the Project Panel by nodeId

     */

  function selectClip(nodeId) {

    var project = app.project;

    if (!project) {

      return JSON.stringify({ success: false, error: 'No active project' });

    }



    var item = findProjectItemByNodeId(project.rootItem, nodeId);

    if (!item) {

      return JSON.stringify({ success: false, error: 'Clip not found' });

    }



    // Select the item in the project panel

    item.select();



    return JSON.stringify({ success: true });

  }



  /**

     * Open clip in Source Monitor

     */

  function openInSourceMonitor(nodeId) {

    var project = app.project;

    if (!project) {

      return JSON.stringify({ success: false, error: 'No active project' });

    }



    var item = findProjectItemByNodeId(project.rootItem, nodeId);

    if (!item) {

      return JSON.stringify({ success: false, error: 'Clip not found' });

    }



    try {

      // Open in Source Monitor

      app.sourceMonitor.openProjectItem(item);

      return JSON.stringify({ success: true });

    } catch (e) {

      return JSON.stringify({

        success: false,

        error: 'Failed to open in Source Monitor: ' + e.toString()

      });

    }

  }



  /**

     * Export frame at specified time from clip

     * @param {string} nodeId - Project item nodeId

     * @param {number} timeInSeconds - Time in seconds (e.g., 0.5 for half a second)

     * @returns {string} JSON with frame file path or error

     *

     * NOTE: This uses a workaround approach since PP ExtendScript doesn't have

     * a direct "export frame at time" API. We:

     * 1. Open clip in Source Monitor

     * 2. Seek to time

     * 3. Export current frame

     */

  function exportFrameAtTime(nodeId, timeInSeconds) {

    var project = app.project;

    if (!project) {

      return JSON.stringify({ success: false, error: 'No active project' });

    }



    var item = findProjectItemByNodeId(project.rootItem, nodeId);

    if (!item) {

      return JSON.stringify({ success: false, error: 'Clip not found' });

    }



    try {

      // Create a temporary folder for frame exports

      var tempFolder = Folder.temp + '/eav-cep-frames';

      var folder = new Folder(tempFolder);

      if (!folder.exists) {

        folder.create();

      }



      // Generate unique filename

      var timestamp = new Date().getTime();

      var outputPath = tempFolder + '/frame-' + nodeId + '-' + timestamp + '.jpg';



      // Method 1: Try using encoder API (PP 2018+)

      // This is the most reliable method if available

      if (app.encoder && typeof app.encoder.encodeFile === 'function') {

        // Convert time to ticks (254016000000 ticks per second)

        var ticksPerSecond = 254016000000;

        var inPoint = Math.floor(timeInSeconds * ticksPerSecond);

        var outPoint = inPoint + 1; // Single frame



        // Use JPEG export preset

        var success = app.encoder.encodeFile(

          item.getMediaPath(),

          outputPath,

          app.encoder.ENCODE_IN_TO_OUT,

          [item],

          inPoint,

          outPoint

        );



        if (success) {

          return JSON.stringify({

            success: true,

            framePath: outputPath,

            timeInSeconds: timeInSeconds,

            method: 'encoder API'

          });

        }

      }



      // Method 2: Fallback - Open in Source Monitor and export current frame

      // This is less reliable but works across more PP versions

      app.sourceMonitor.openProjectItem(item);



      // Seek to time (in ticks)

      var ticksPerSecond = 254016000000;

      var timeInTicks = Math.floor(timeInSeconds * ticksPerSecond);

      app.sourceMonitor.setPosition(timeInTicks);



      // Export current frame (if method exists)

      // Note: exportFramePNG may not exist in all PP versions

      if (typeof item.exportFramePNG === 'function') {

        var success = item.exportFramePNG(timeInTicks, outputPath);



        if (success) {

          return JSON.stringify({

            success: true,

            framePath: outputPath,

            timeInSeconds: timeInSeconds,

            method: 'exportFramePNG'

          });

        }

      }



      // Method 3: Ultimate fallback - return media path

      // CEP panel will handle frame extraction client-side if needed

      return JSON.stringify({

        success: false,

        error: 'Frame export API not available in this PP version',

        fallback: 'use_media_path',

        mediaPath: item.getMediaPath(),

        timeInSeconds: timeInSeconds

      });



    } catch (e) {

      return JSON.stringify({

        success: false,

        error: 'Failed to export frame: ' + e.toString(),

        details: 'Time: ' + timeInSeconds + 's'

      });

    }

  }



  /**

     * Parse structured naming from original filename

     * Expects format: {8-digit-id}-restofname.ext

     */

  function parseStructuredNaming(filename) {

    // Remove extension

    var nameWithoutExt = filename.replace(/\.[^.]+$/, '');



    // Try to extract 8-digit ID

    var idMatch = nameWithoutExt.match(/^(\d{8})/);

    var id = idMatch ? idMatch[1] : '';



    return JSON.stringify({

      id: id,

      originalFilename: filename

    });

  }



  // Public API

  return {

    getSelectedClips: getSelectedClips,

    updateClipMetadata: updateClipMetadata,

    readJSONMetadata: readJSONMetadataWrapper,

    writeJSONMetadata: writeJSONMetadataWrapper,

    readJSONMetadataByNodeId: readJSONMetadataByNodeIdWrapper,

    writeJSONMetadataByNodeId: writeJSONMetadataByNodeIdWrapper,

    getAllProjectClips: getAllProjectClips,

    selectClip: selectClip,

    openInSourceMonitor: openInSourceMonitor,

    exportFrameAtTime: exportFrameAtTime,

    parseStructuredNaming: parseStructuredNaming

  };

})();



// Make functions available to CEP panel

EAVIngest;
