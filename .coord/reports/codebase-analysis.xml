This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: jsx/**, js/**, css/**, *.html
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
css/
  metadata-panel.css
  navigation-panel.css
  panel-layout.css
  style.css
js/
  CSInterface.js
  main.js
  metadata-panel.js
  navigation-panel.js
  panel-main.js
jsx/
  host.jsx
index-metadata.html
index-navigation.html
index-old.html
index.html
test-cep-load.html
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="css/metadata-panel.css">
/* Metadata Panel - Form (80%) | Debug Panel (20%) */

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 12px;
    color: #d0d0d0;
    background-color: #1e1e1e;
    overflow: hidden;
}

/* ========================================
   MAIN CONTAINER: Horizontal Split
   ======================================== */

.metadata-panel-container {
    display: flex;
    flex-direction: row;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
}

/* ========================================
   LEFT SECTION: METADATA FORM (80%)
   ======================================== */

.metadata-form-section {
    flex: 80%;
    background-color: #252525;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Form Header */
.form-header {
    padding: 12px 16px;
    background-color: #2b2b2b;
    border-bottom: 1px solid #3a3a3a;
}

.form-header h3 {
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 4px;
}

.form-clip-name {
    font-size: 11px;
    color: #808080;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    display: block;
}

/* Form Content */
.form-content {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
}

.form-group {
    margin-bottom: 16px;
}

.form-group label {
    display: block;
    font-size: 11px;
    font-weight: 600;
    margin-bottom: 4px;
    color: #b0b0b0;
}

/* Split row for Tape Name | Description | Good (20/70/10) */
.form-row-split {
    display: flex;
    gap: 8px;
    margin-bottom: 16px;
    align-items: flex-end; /* Align inputs at bottom */
}

.form-group-split {
    min-width: 0; /* Allow flex items to shrink */
}

.form-group-split label {
    display: block;
    font-size: 11px;
    font-weight: 600;
    margin-bottom: 4px;
    color: #b0b0b0;
}

.form-group-split input[type="text"] {
    width: 100%;
    padding: 6px 8px;
    background-color: #1e1e1e;
    border: 1px solid #404040;
    border-radius: 4px;
    color: #d0d0d0;
    font-size: 12px;
}

.form-group-split input[type="text"]:focus {
    outline: none;
    border-color: #0078d4;
}

/* Checkbox styling for Good field */
.form-group-checkbox {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.checkbox-good {
    width: 20px;
    height: 20px;
    cursor: pointer;
    accent-color: #0078d4;
}

/* Single-line form row */
.form-row {
    display: flex;
    gap: 8px;
    margin-bottom: 16px;
}

.form-group-inline {
    flex: 1;
    min-width: 0; /* Allow flex items to shrink */
}

.form-group-inline label {
    display: block;
    font-size: 11px;
    font-weight: 600;
    margin-bottom: 4px;
    color: #b0b0b0;
}

.form-group input[type="text"],
.form-group select,
.form-group-inline input[type="text"],
.form-group-inline select {
    width: 100%;
    padding: 6px 8px;
    background-color: #1e1e1e;
    border: 1px solid #404040;
    border-radius: 4px;
    color: #d0d0d0;
    font-size: 12px;
}

.form-group input[type="text"]:focus,
.form-group select:focus,
.form-group-inline input[type="text"]:focus,
.form-group-inline select:focus {
    outline: none;
    border-color: #0078d4;
}

.form-group input.readonly-field,
.form-group-split input.readonly-field {
    background-color: #2b2b2b;
    color: #808080;
    cursor: not-allowed;
}

.form-group small {
    display: block;
    font-size: 10px;
    color: #808080;
    margin-top: 4px;
}

/* Generated Name Preview */
.name-preview {
    margin-top: 16px;
    padding: 12px;
    background-color: #2b2b2b;
    border-radius: 4px;
}

.name-preview label {
    display: block;
    font-size: 11px;
    font-weight: 600;
    margin-bottom: 6px;
    color: #b0b0b0;
}

.generated-name-text {
    font-size: 13px;
    color: #4ec9b0;
    font-family: 'Courier New', monospace;
    word-break: break-all;
}

/* Form Actions */
.form-actions {
    padding: 16px;
    background-color: #2b2b2b;
    border-top: 1px solid #3a3a3a;
}

.btn-primary {
    width: 100%;
    padding: 12px;
    background-color: #0078d4;
    border: none;
    border-radius: 4px;
    color: #ffffff;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.15s;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.btn-primary:hover:not(:disabled) {
    background-color: #005a9e;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.btn-primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
}

/* Form Status Messages */
.form-status {
    padding: 8px 16px;
    font-size: 11px;
    text-align: center;
    min-height: 28px;
}

.form-status.info {
    color: #4fc3f7;
}

.form-status.success {
    color: #4ec9b0;
}

.form-status.error {
    color: #f48771;
}

/* ========================================
   RIGHT SECTION: DEBUG PANEL (20%)
   ======================================== */

.debug-panel-section {
    flex: 20%;
    background-color: #1a1a1a;
    border-left: 2px solid #0f0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.debug-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 8px;
    background-color: #0a0a0a;
    border-bottom: 1px solid #0f0;
}

.debug-title {
    font-family: 'Courier New', monospace;
    font-size: 11px;
    color: #0f0;
    font-weight: 600;
    text-transform: uppercase;
}

.icon-btn-small {
    padding: 2px 6px;
    background-color: transparent;
    border: 1px solid #0f0;
    border-radius: 3px;
    color: #0f0;
    cursor: pointer;
    font-size: 10px;
    font-family: 'Courier New', monospace;
}

.icon-btn-small:hover {
    background-color: #0f0;
    color: #000;
}

.debug-content {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
    font-family: 'Courier New', monospace;
    font-size: 10px;
    line-height: 1.4;
}

.debug-line {
    display: flex;
    gap: 8px;
    margin-bottom: 2px;
    padding: 2px 4px;
}

.debug-line.error {
    background-color: rgba(255, 0, 0, 0.1);
}

.debug-time {
    color: #666;
    flex-shrink: 0;
}

.debug-message {
    color: #0f0;
    word-break: break-word;
}

.debug-line.error .debug-message {
    color: #f00;
}

/* ========================================
   SCROLLBAR STYLING
   ======================================== */

::-webkit-scrollbar {
    width: 12px;
    height: 12px;
}

::-webkit-scrollbar-track {
    background: #1e1e1e;
}

::-webkit-scrollbar-thumb {
    background: #404040;
    border-radius: 6px;
}

::-webkit-scrollbar-thumb:hover {
    background: #505050;
}

/* Debug panel scrollbar - green theme */
.debug-content::-webkit-scrollbar-thumb {
    background: #0f0;
}

.debug-content::-webkit-scrollbar-thumb:hover {
    background: #0c0;
}

/* ========================================
   SEARCHABLE DROPDOWN
   ======================================== */

.searchable-dropdown {
    position: relative;
    width: 100%;
}

.searchable-input {
    width: 100%;
    padding: 6px 8px;
    background-color: #2a2a2a;
    border: 1px solid #444;
    border-radius: 3px;
    color: #e0e0e0;
    font-size: 11px;
    outline: none;
    transition: border-color 0.2s;
}

.searchable-input:focus {
    border-color: #0078d4;
}

.dropdown-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    max-height: 200px;
    overflow-y: auto;
    background-color: #2a2a2a;
    border: 1px solid #444;
    border-top: none;
    border-radius: 0 0 3px 3px;
    z-index: 1000;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.dropdown-option {
    padding: 8px 12px;
    cursor: pointer;
    font-size: 11px;
    color: #d0d0d0;
    transition: background-color 0.15s;
}

.dropdown-option:hover,
.dropdown-option.highlighted {
    background-color: #0078d4;
    color: #fff;
}

.dropdown-option.hidden {
    display: none;
}

/* Scrollbar styling for dropdown */
.dropdown-list::-webkit-scrollbar {
    width: 8px;
}

.dropdown-list::-webkit-scrollbar-track {
    background: #1e1e1e;
}

.dropdown-list::-webkit-scrollbar-thumb {
    background: #555;
    border-radius: 4px;
}

.dropdown-list::-webkit-scrollbar-thumb:hover {
    background: #666;
}

/* ========================================
   NAVIGATION BUTTONS ROW
   ======================================== */

.nav-buttons-row {
    display: flex;
    gap: 8px;
    align-items: center;
}

.btn-nav {
    flex: 1;
    padding: 8px 16px;
    background-color: #2a2a2a;
    border: 1px solid #444;
    border-radius: 3px;
    color: #e0e0e0;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
}

.btn-nav:hover:not(:disabled) {
    background-color: #3a3a3a;
    border-color: #0078d4;
}

.btn-nav:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.btn-primary {
    flex: 2; /* Make apply button wider than nav buttons */
}
</file>

<file path="css/style.css">
/* CEP Panel Styling - Horizontal Strip Layout */



* {

    box-sizing: border-box;

    margin: 0;

    padding: 0;

}



body {

    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;

    font-size: 12px;

    color: #d0d0d0;

    background-color: #2b2b2b;

    overflow-x: hidden;

    overflow-y: auto;

}



.panel-container {

    padding: 8px;

    display: flex;

    flex-direction: column;

    gap: 8px;

    height: 100vh;

}



/* Header */

.header {

    display: flex;

    justify-content: space-between;

    align-items: center;

    padding: 6px 8px;

    background-color: #3a3a3a;

    border-radius: 4px;

    border-bottom: 1px solid #505050;

}



.clip-info {

    flex: 1;

    overflow: hidden;

}



.clip-name {

    display: block;

    font-weight: 600;

    font-size: 13px;

    color: #e0e0e0;

    white-space: nowrap;

    overflow: hidden;

    text-overflow: ellipsis;

}



.clip-path {

    display: block;

    font-size: 10px;

    color: #909090;

    white-space: nowrap;

    overflow: hidden;

    text-overflow: ellipsis;

    margin-top: 2px;

}



.icon-btn {

    background: transparent;

    border: 1px solid #505050;

    color: #b0b0b0;

    padding: 4px 6px;

    cursor: pointer;

    border-radius: 3px;

    display: flex;

    align-items: center;

    justify-content: center;

}



.icon-btn:hover {

    background-color: #454545;

    border-color: #606060;

}



/* Form Strip - Horizontal Layout */

.form-strip {

    display: flex;

    gap: 8px;

    flex-wrap: wrap;

    padding: 8px;

    background-color: #323232;

    border-radius: 4px;

}



.form-group {

    display: flex;

    flex-direction: column;

    gap: 4px;

    flex: 1;

    min-width: 100px;

}



.form-group.compact {

    flex: 0 0 80px;

    min-width: 80px;

}



.form-group label {

    font-size: 10px;

    font-weight: 500;

    color: #a0a0a0;

    text-transform: uppercase;

    letter-spacing: 0.5px;

}



.form-group input,

.form-group select {

    padding: 6px 8px;

    background-color: #404040;

    border: 1px solid #505050;

    border-radius: 3px;

    color: #e0e0e0;

    font-size: 12px;

    font-family: inherit;

}



.form-group input:focus,

.form-group select:focus {

    outline: none;

    border-color: #0078d4;

    background-color: #454545;

}



.form-group input::placeholder {

    color: #707070;

    font-style: italic;

}



.readonly-field {

    background-color: #353535 !important;

    color: #909090 !important;

    cursor: not-allowed;

}



/* Name Preview */

.name-preview {

    padding: 8px;

    background-color: #2a2a2a;

    border-radius: 4px;

    border: 1px solid #404040;

}



.name-preview label {

    font-size: 10px;

    font-weight: 600;

    color: #a0a0a0;

    text-transform: uppercase;

    display: block;

    margin-bottom: 4px;

}



.generated-name-text {

    font-family: "Courier New", Courier, monospace;

    font-size: 13px;

    color: #4ec9b0;

    font-weight: 500;

    word-break: break-all;

}



/* Metadata Section */

.metadata-section {

    padding: 8px;

    background-color: #323232;

    border-radius: 4px;

}



.metadata-section label {

    font-size: 10px;

    font-weight: 500;

    color: #a0a0a0;

    text-transform: uppercase;

    display: block;

    margin-bottom: 4px;

}



.metadata-section input {

    width: 100%;

    padding: 6px 8px;

    background-color: #404040;

    border: 1px solid #505050;

    border-radius: 3px;

    color: #e0e0e0;

    font-size: 12px;

    font-family: inherit;

}



.metadata-section input:focus {

    outline: none;

    border-color: #0078d4;

    background-color: #454545;

}



/* Action Bar */

.action-bar {

    display: flex;

    justify-content: space-between;

    align-items: center;

    gap: 8px;

    padding: 8px;

    background-color: #3a3a3a;

    border-radius: 4px;

    border-top: 1px solid #505050;

}



.nav-buttons {

    display: flex;

    gap: 6px;

}



.action-buttons {

    display: flex;

    gap: 6px;

}



/* Buttons */

button {

    font-family: inherit;

    font-size: 12px;

    cursor: pointer;

    border-radius: 3px;

    transition: all 0.15s ease;

}



.nav-btn {

    padding: 6px 12px;

    background-color: #454545;

    border: 1px solid #505050;

    color: #d0d0d0;

}



.nav-btn:hover:not(:disabled) {

    background-color: #505050;

    border-color: #606060;

}



.nav-btn:disabled {

    opacity: 0.4;

    cursor: not-allowed;

}



.primary-btn {

    padding: 6px 16px;

    background-color: #0078d4;

    border: 1px solid #0078d4;

    color: #ffffff;

    font-weight: 500;

}



.primary-btn:hover:not(:disabled) {

    background-color: #005a9e;

    border-color: #005a9e;

}



.primary-btn:disabled {

    opacity: 0.5;

    cursor: not-allowed;

}



.secondary-btn {

    padding: 6px 12px;

    background-color: #3a3a3a;

    border: 1px solid #505050;

    color: #d0d0d0;

}



.secondary-btn:hover:not(:disabled) {

    background-color: #454545;

    border-color: #606060;

}



/* Status Messages */

.status-msg {

    padding: 8px;

    border-radius: 3px;

    font-size: 11px;

    text-align: center;

    display: none;

}



.status-msg.success {

    display: block;

    background-color: #1a3a1a;

    border: 1px solid #2d5f2d;

    color: #6bcf6b;

}



.status-msg.error {

    display: block;

    background-color: #3a1a1a;

    border: 1px solid #5f2d2d;

    color: #cf6b6b;

}



.status-msg.info {

    display: block;

    background-color: #1a2a3a;

    border: 1px solid #2d4a5f;

    color: #6b9fcf;

}



/* AI Section (Phase 2) */

.ai-section {

    padding: 8px;

    background-color: #2a2a3a;

    border-radius: 4px;

    border: 1px solid #4a4a5a;

}



.ai-status {

    margin-top: 6px;

    font-size: 11px;

    color: #b0b0c0;

}



/* Scrollbar Styling */

::-webkit-scrollbar {

    width: 10px;

}



::-webkit-scrollbar-track {

    background: #2b2b2b;

}



::-webkit-scrollbar-thumb {

    background: #505050;

    border-radius: 5px;

}



::-webkit-scrollbar-thumb:hover {

    background: #606060;

}



/* Responsive adjustments for narrow panels */

@media (max-width: 500px) {

    .form-strip {

        flex-direction: column;

    }



    .action-bar {

        flex-direction: column;

    }



    .nav-buttons,

    .action-buttons {

        width: 100%;

    }



    .nav-btn,

    .primary-btn,

    .secondary-btn {

        flex: 1;

    }

}
</file>

<file path="js/CSInterface.js">
/**************************************************************************************************
*
* ADOBE SYSTEMS INCORPORATED
* Copyright 2013 Adobe Systems Incorporated
* All Rights Reserved.
*
* NOTICE:  Adobe permits you to use, modify, and distribute this file in accordance with the
* terms of the Adobe license agreement accompanying it.  If you have received this file from a
* source other than Adobe, then your use, modification, or distribution of it requires the prior
* written permission of Adobe.
*
**************************************************************************************************/

/** CSInterface - v9.4.0 */

/**
 * Stores constants for the window types supported by the CSXS infrastructure.
 */
function CSXSWindowType()
{
}

/** Constant for the CSXS window type Panel. */
CSXSWindowType._PANEL = "Panel";

/** Constant for the CSXS window type Modeless. */
CSXSWindowType._MODELESS = "Modeless";

/** Constant for the CSXS window type ModalDialog. */
CSXSWindowType._MODAL_DIALOG = "ModalDialog";

/** EvalScript error message */
EvalScript_ErrMessage = "EvalScript error.";

/**
 * @class Version
 * Defines a version number with major, minor, micro, and special
 * components. The major, minor and micro values are numeric; the special
 * value can be any string.
 *
 * @param major   The major version component, a positive integer up to nine digits long.
 * @param minor   The minor version component, a positive integer up to nine digits long.
 * @param micro   The micro version component, a positive integer up to nine digits long.
 * @param special The special version component, an arbitrary string.
 *
 * @return A new \c Version object.
 */
function Version(major, minor, micro, special)
{
    this.major = major;
    this.minor = minor;
    this.micro = micro;
    this.special = special;
}

/**
 * The maximum value allowed for a numeric version component.
 * This reflects the maximum value allowed in PlugPlug and the manifest schema.
 */
Version.MAX_NUM = 999999999;

/**
 * @class VersionBound
 * Defines a boundary for a version range, which associates a \c Version object
 * with a flag for whether it is an inclusive or exclusive boundary.
 *
 * @param version   The \c #Version object.
 * @param inclusive True if this boundary is inclusive, false if it is exclusive.
 *
 * @return A new \c VersionBound object.
 */
function VersionBound(version, inclusive)
{
    this.version = version;
    this.inclusive = inclusive;
}

/**
 * @class VersionRange
 * Defines a range of versions using a lower boundary and optional upper boundary.
 *
 * @param lowerBound The \c #VersionBound object.
 * @param upperBound The \c #VersionBound object, or null for a range with no upper boundary.
 *
 * @return A new \c VersionRange object.
 */
function VersionRange(lowerBound, upperBound)
{
    this.lowerBound = lowerBound;
    this.upperBound = upperBound;
}

/**
 * @class Runtime
 * Represents a runtime related to the CEP infrastructure.
 * Extensions can declare dependencies on particular
 * CEP runtime versions in the extension manifest.
 *
 * @param name    The runtime name.
 * @param version A \c #VersionRange object that defines a range of valid versions.
 *
 * @return A new \c Runtime object.
 */
function Runtime(name, versionRange)
{
    this.name = name;
    this.versionRange = versionRange;
}

/**
* @class Extension
* Encapsulates a CEP-based extension to an Adobe application.
*
* @param id              The unique identifier of this extension.
* @param name            The localizable display name of this extension.
* @param mainPath        The path of the "index.html" file.
* @param basePath        The base path of this extension.
* @param windowType          The window type of the main window of this extension.
                 Valid values are defined by \c #CSXSWindowType.
* @param width           The default width in pixels of the main window of this extension.
* @param height          The default height in pixels of the main window of this extension.
* @param minWidth        The minimum width in pixels of the main window of this extension.
* @param minHeight       The minimum height in pixels of the main window of this extension.
* @param maxWidth        The maximum width in pixels of the main window of this extension.
* @param maxHeight       The maximum height in pixels of the main window of this extension.
* @param defaultExtensionDataXml The extension data contained in the default \c ExtensionDispatchInfo section of the extension manifest.
* @param specialExtensionDataXml The extension data contained in the application-specific \c ExtensionDispatchInfo section of the extension manifest.
* @param requiredRuntimeList     An array of \c Runtime objects for runtimes required by this extension.
* @param isAutoVisible       True if this extension is visible on loading.
* @param isPluginExtension   True if this extension has been deployed in the Plugins folder of the host application.
*
* @return A new \c Extension object.
*/
function Extension(id, name, mainPath, basePath, windowType, width, height, minWidth, minHeight, maxWidth, maxHeight,
                   defaultExtensionDataXml, specialExtensionDataXml, requiredRuntimeList, isAutoVisible, isPluginExtension)
{
    this.id = id;
    this.name = name;
    this.mainPath = mainPath;
    this.basePath = basePath;
    this.windowType = windowType;
    this.width = width;
    this.height = height;
    this.minWidth = minWidth;
    this.minHeight = minHeight;
    this.maxWidth = maxWidth;
    this.maxHeight = maxHeight;
    this.defaultExtensionDataXml = defaultExtensionDataXml;
    this.specialExtensionDataXml = specialExtensionDataXml;
    this.requiredRuntimeList = requiredRuntimeList;
    this.isAutoVisible = isAutoVisible;
    this.isPluginExtension = isPluginExtension;
}

/**
 * @class CSEvent
 * A standard JavaScript event, the base class for CEP events.
 *
 * @param type        The name of the event type.
 * @param scope       The scope of event, can be "GLOBAL" or "APPLICATION".
 * @param appId       The unique identifier of the application that generated the event.
 * @param extensionId     The unique identifier of the extension that generated the event.
 *
 * @return A new \c CSEvent object
 */
function CSEvent(type, scope, appId, extensionId)
{
    this.type = type;
    this.scope = scope;
    this.appId = appId;
    this.extensionId = extensionId;
}

/** Event-specific data. */
CSEvent.prototype.data = "";

/**
 * @class SystemPath
 * Stores operating-system-specific location constants for use in the
 * \c #CSInterface.getSystemPath() method.
 * @return A new \c SystemPath object.
 */
function SystemPath()
{
}

/** The path to user data.  */
SystemPath.USER_DATA = "userData";

/** The path to common files for Adobe applications.  */
SystemPath.COMMON_FILES = "commonFiles";

/** The path to the user's default document folder.  */
SystemPath.MY_DOCUMENTS = "myDocuments";

/** @deprecated. Use \c #SystemPath.Extension.  */
SystemPath.APPLICATION = "application";

/** The path to current extension.  */
SystemPath.EXTENSION = "extension";

/** The path to hosting application's executable.  */
SystemPath.HOST_APPLICATION = "hostApplication";

/**
 * @class ColorType
 * Stores color-type constants.
 */
function ColorType()
{
}

/** RGB color type. */
ColorType.RGB = "rgb";

/** Gradient color type. */
ColorType.GRADIENT = "gradient";

/** Null color type. */
ColorType.NONE = "none";

/**
 * @class RGBColor
 * Stores an RGB color with red, green, blue, and alpha values.
 * All values are in the range [0.0 to 255.0]. Invalid numeric values are
 * converted to numbers within this range.
 *
 * @param red   The red value, in the range [0.0 to 255.0].
 * @param green The green value, in the range [0.0 to 255.0].
 * @param blue  The blue value, in the range [0.0 to 255.0].
 * @param alpha The alpha (transparency) value, in the range [0.0 to 255.0].
 *      The default, 255.0, means that the color is fully opaque.
 *
 * @return A new RGBColor object.
 */
function RGBColor(red, green, blue, alpha)
{
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
}

/**
 * @class Direction
 * A point value  in which the y component is 0 and the x component
 * is positive or negative for a right or left direction,
 * or the x component is 0 and the y component is positive or negative for
 * an up or down direction.
 *
 * @param x     The horizontal component of the point.
 * @param y     The vertical component of the point.
 *
 * @return A new \c Direction object.
 */
function Direction(x, y)
{
    this.x = x;
    this.y = y;
}

/**
 * @class GradientStop
 * Stores gradient stop information.
 *
 * @param offset   The offset of the gradient stop, in the range [0.0 to 1.0].
 * @param rgbColor The color of the gradient at this point, an \c #RGBColor object.
 *
 * @return GradientStop object.
 */
function GradientStop(offset, rgbColor)
{
    this.offset = offset;
    this.rgbColor = rgbColor;
}

/**
 * @class GradientColor
 * Stores gradient color information.
 *
 * @param type          The gradient type, must be "linear".
 * @param direction     A \c #Direction object for the direction of the gradient
                (up, down, right, or left).
 * @param numStops          The number of stops in the gradient.
 * @param gradientStopList  An array of \c #GradientStop objects.
 *
 * @return A new \c GradientColor object.
 */
function GradientColor(type, direction, numStops, arrGradientStop)
{
    this.type = type;
    this.direction = direction;
    this.numStops = numStops;
    this.arrGradientStop = arrGradientStop;
}

/**
 * @class UIColor
 * Stores color information, including the type, anti-alias level, and specific color
 * values in a color object of an appropriate type.
 *
 * @param type          The color type, 1 for "rgb" and 2 for "gradient".
                The supplied color object must correspond to this type.
 * @param antialiasLevel    The anti-alias level constant.
 * @param color         A \c #RGBColor or \c #GradientColor object containing specific color information.
 *
 * @return A new \c UIColor object.
 */
function UIColor(type, antialiasLevel, color)
{
    this.type = type;
    this.antialiasLevel = antialiasLevel;
    this.color = color;
}

/**
 * @class AppSkinInfo
 * Stores window-skin properties, such as color and font. All color parameter values are \c #UIColor objects except that systemHighlightColor is \c #RGBColor object.
 *
 * @param baseFontFamily        The base font family of the application.
 * @param baseFontSize          The base font size of the application.
 * @param appBarBackgroundColor     The application bar background color.
 * @param panelBackgroundColor      The background color of the extension panel.
 * @param appBarBackgroundColorSRGB     The application bar background color, as sRGB.
 * @param panelBackgroundColorSRGB      The background color of the extension panel, as sRGB.
 * @param systemHighlightColor          The highlight color of the extension panel, if provided by the host application. Otherwise, the operating-system highlight color.
 *
 * @return AppSkinInfo object.
 */
function AppSkinInfo(baseFontFamily, baseFontSize, appBarBackgroundColor, panelBackgroundColor, appBarBackgroundColorSRGB, panelBackgroundColorSRGB, systemHighlightColor)
{
    this.baseFontFamily = baseFontFamily;
    this.baseFontSize = baseFontSize;
    this.appBarBackgroundColor = appBarBackgroundColor;
    this.panelBackgroundColor = panelBackgroundColor;
    this.appBarBackgroundColorSRGB = appBarBackgroundColorSRGB;
    this.panelBackgroundColorSRGB = panelBackgroundColorSRGB;
    this.systemHighlightColor = systemHighlightColor;
}

/**
 * @class HostEnvironment
 * Stores information about the environment in which the extension is loaded.
 *
 * @param appName   The application's name.
 * @param appVersion    The application's version.
 * @param appLocale The application's current license locale.
 * @param appUILocale   The application's current UI locale.
 * @param appId     The application's unique identifier.
 * @param isAppOnline  True if the application is currently online.
 * @param appSkinInfo   An \c #AppSkinInfo object containing the application's default color and font styles.
 *
 * @return A new \c HostEnvironment object.
 */
function HostEnvironment(appName, appVersion, appLocale, appUILocale, appId, isAppOnline, appSkinInfo)
{
    this.appName = appName;
    this.appVersion = appVersion;
    this.appLocale = appLocale;
    this.appUILocale = appUILocale;
    this.appId = appId;
    this.isAppOnline = isAppOnline;
    this.appSkinInfo = appSkinInfo;
}

/**
 * @class HostCapabilities
 * Stores information about the host capabilities.
 *
 * @param EXTENDED_PANEL_MENU True if the application supports panel menu.
 * @param EXTENDED_PANEL_ICONS True if the application supports panel icon.
 * @param DELEGATE_APE_ENGINE True if the application supports delegated APE engine.
 * @param SUPPORT_HTML_EXTENSIONS True if the application supports HTML extensions.
 * @param DISABLE_FLASH_EXTENSIONS True if the application disables FLASH extensions.
 *
 * @return A new \c HostCapabilities object.
 */
function HostCapabilities(EXTENDED_PANEL_MENU, EXTENDED_PANEL_ICONS, DELEGATE_APE_ENGINE, SUPPORT_HTML_EXTENSIONS, DISABLE_FLASH_EXTENSIONS)
{
    this.EXTENDED_PANEL_MENU = EXTENDED_PANEL_MENU;
    this.EXTENDED_PANEL_ICONS = EXTENDED_PANEL_ICONS;
    this.DELEGATE_APE_ENGINE = DELEGATE_APE_ENGINE;
    this.SUPPORT_HTML_EXTENSIONS = SUPPORT_HTML_EXTENSIONS;
    this.DISABLE_FLASH_EXTENSIONS = DISABLE_FLASH_EXTENSIONS; // Since 5.0.0
}

/**
 * @class ApiVersion
 * Stores current api version.
 *
 * Since 4.2.0
 *
 * @param major  The major version
 * @param minor  The minor version.
 * @param micro  The micro version.
 *
 * @return ApiVersion object.
 */
function ApiVersion(major, minor, micro)
{
    this.major = major;
    this.minor = minor;
    this.micro = micro;
}

/**
 * @class MenuItemStatus
 * Stores flyout menu item status
 *
 * Since 5.2.0
 *
 * @param menuItemLabel  The menu item label.
 * @param enabled        True if user wants to enable the menu item.
 * @param checked        True if user wants to check the menu item.
 *
 * @return MenuItemStatus object.
 */
function MenuItemStatus(menuItemLabel, enabled, checked)
{
    this.menuItemLabel = menuItemLabel;
    this.enabled = enabled;
    this.checked = checked;
}

/**
 * @class ContextMenuItemStatus
 * Stores the status of the context menu item.
 *
 * Since 5.2.0
 *
 * @param menuItemID     The menu item id.
 * @param enabled        True if user wants to enable the menu item.
 * @param checked        True if user wants to check the menu item.
 *
 * @return MenuItemStatus object.
 */
function ContextMenuItemStatus(menuItemID, enabled, checked)
{
    this.menuItemID = menuItemID;
    this.enabled = enabled;
    this.checked = checked;
}
//------------------------------ CSInterface ----------------------------------

/**
 * @class CSInterface
 * This is the entry point to the CEP extensibility infrastructure.
 * Instantiate this object and use it to:
 * <ul>
 * <li>Access information about the host application in which an extension is running</li>
 * <li>Launch an extension</li>
 * <li>Register interest in event notifications, and dispatch events</li>
 * </ul>
 *
 * @return A new \c CSInterface object
 */
function CSInterface()
{
}

/**
 * User can add this event listener to handle native application theme color changes.
 * Callback function gives extensions ability to fine-tune their theme color after the
 * global theme color has been changed.
 * The callback function should be like below:
 *
 * @example
 * // event is a CSEvent object, but user can ignore it.
 * function OnAppThemeColorChanged(event)
 * {
 *    // Should get a latest HostEnvironment object from application.
 *    var skinInfo = JSON.parse(window.__adobe_cep__.getHostEnvironment()).appSkinInfo;
 *    // Gets the style information such as color info from the skinInfo,
 *    // and redraw all UI controls of your extension according to the style info.
 * }
 */
CSInterface.THEME_COLOR_CHANGED_EVENT = "com.adobe.csxs.events.ThemeColorChanged";

/** The host environment data object. */
CSInterface.prototype.hostEnvironment = window.__adobe_cep__ ? JSON.parse(window.__adobe_cep__.getHostEnvironment()) : null;

/** Retrieves information about the host environment in which the
 *  extension is currently running.
 *
 *   @return A \c #HostEnvironment object.
 */
CSInterface.prototype.getHostEnvironment = function()
{
    this.hostEnvironment = JSON.parse(window.__adobe_cep__.getHostEnvironment());
    return this.hostEnvironment;
};

/** Loads binary file created which is located at url asynchronously
*
*@param urlName url at which binary file is located. Local files should start with 'file://'
*@param callback Optional. A callback function that returns after binary is loaded

*@example
* To create JS binary use command ./cep_compiler test.js test.bin
* To load JS binary asyncronously
*   var CSLib = new CSInterface();
*   CSLib.loadBinAsync(url, function () { });
*/
CSInterface.prototype.loadBinAsync = function(urlName,callback)
{
    try
    {
        var xhr = new XMLHttpRequest();
        xhr.responseType = 'arraybuffer'; // make response as ArrayBuffer
        xhr.open('GET', urlName, true);
        xhr.onerror = function ()
        {
  		  console.log("Unable to load snapshot from given URL");
  		  return false;
		};
        xhr.send();
        xhr.onload = () => {
            window.__adobe_cep__.loadSnapshot(xhr.response);
            if (typeof callback === "function")
            {
                callback();
            }
            else if(typeof callback !== "undefined")
            {
                console.log("Provided callback is not a function");
            }
        }
    }
    catch(err)
    {
        console.log(err);
        return false;
    }

	return true;
};

/** Loads binary file created synchronously
*
*@param pathName the local path at which binary file is located

*@example
* To create JS binary use command ./cep_compiler test.js test.bin
* To load JS binary syncronously
*   var CSLib = new CSInterface();
*   CSLib.loadBinSync(path);
*/
CSInterface.prototype.loadBinSync  = function(pathName)
{
    try
    {
        var OSVersion = this.getOSInformation();
        if(pathName.startsWith("file://"))
        {
            if (OSVersion.indexOf("Windows") >= 0)
            {
               pathName = pathName.replace("file:///", "");
            }
            else if (OSVersion.indexOf("Mac") >= 0)
            {
                pathName = pathName.replace("file://", "");
            }
            window.__adobe_cep__.loadSnapshot(pathName);
            return true;
        }
    }
    catch(err)
    {
        console.log(err);
        return false;
    }
    //control should not come here
    return false;
};

/** Closes this extension. */
CSInterface.prototype.closeExtension = function()
{
    window.__adobe_cep__.closeExtension();
};

/**
 * Retrieves a path for which a constant is defined in the system.
 *
 * @param pathType The path-type constant defined in \c #SystemPath ,
 *
 * @return The platform-specific system path string.
 */
CSInterface.prototype.getSystemPath = function(pathType)
{
    var path = decodeURI(window.__adobe_cep__.getSystemPath(pathType));
    var OSVersion = this.getOSInformation();
    if (OSVersion.indexOf("Windows") >= 0)
    {
      path = path.replace("file:///", "");
    }
    else if (OSVersion.indexOf("Mac") >= 0)
    {
      path = path.replace("file://", "");
    }
    return path;
};

/**
 * Evaluates a JavaScript script, which can use the JavaScript DOM
 * of the host application.
 *
 * @param script    The JavaScript script.
 * @param callback  Optional. A callback function that receives the result of execution.
 *          If execution fails, the callback function receives the error message \c EvalScript_ErrMessage.
 */
CSInterface.prototype.evalScript = function(script, callback)
{
    if(callback === null || callback === undefined)
    {
        callback = function(result){};
    }
    window.__adobe_cep__.evalScript(script, callback);
};

/**
 * Retrieves the unique identifier of the application.
 * in which the extension is currently running.
 *
 * @return The unique ID string.
 */
CSInterface.prototype.getApplicationID = function()
{
    var appId = this.hostEnvironment.appId;
    return appId;
};

/**
 * Retrieves host capability information for the application
 * in which the extension is currently running.
 *
 * @return A \c #HostCapabilities object.
 */
CSInterface.prototype.getHostCapabilities = function()
{
    var hostCapabilities = JSON.parse(window.__adobe_cep__.getHostCapabilities() );
    return hostCapabilities;
};

/**
 * Triggers a CEP event programmatically. Yoy can use it to dispatch
 * an event of a predefined type, or of a type you have defined.
 *
 * @param event A \c CSEvent object.
 */
CSInterface.prototype.dispatchEvent = function(event)
{
    if (typeof event.data == "object")
    {
        event.data = JSON.stringify(event.data);
    }

    window.__adobe_cep__.dispatchEvent(event);
};

/**
 * Registers an interest in a CEP event of a particular type, and
 * assigns an event handler.
 * The event infrastructure notifies your extension when events of this type occur,
 * passing the event object to the registered handler function.
 *
 * @param type     The name of the event type of interest.
 * @param listener The JavaScript handler function or method.
 * @param obj      Optional, the object containing the handler method, if any.
 *         Default is null.
 */
CSInterface.prototype.addEventListener = function(type, listener, obj)
{
    window.__adobe_cep__.addEventListener(type, listener, obj);
};

/**
 * Removes a registered event listener.
 *
 * @param type      The name of the event type of interest.
 * @param listener  The JavaScript handler function or method that was registered.
 * @param obj       Optional, the object containing the handler method, if any.
 *          Default is null.
 */
CSInterface.prototype.removeEventListener = function(type, listener, obj)
{
    window.__adobe_cep__.removeEventListener(type, listener, obj);
};

/**
 * Loads and launches another extension, or activates the extension if it is already loaded.
 *
 * @param extensionId       The extension's unique identifier.
 * @param startupParams     Not currently used, pass "".
 *
 * @example
 * To launch the extension "help" with ID "HLP" from this extension, call:
 * <code>requestOpenExtension("HLP", ""); </code>
 *
 */
CSInterface.prototype.requestOpenExtension = function(extensionId, params)
{
    window.__adobe_cep__.requestOpenExtension(extensionId, params);
};

/**
 * Retrieves the list of extensions currently loaded in the current host application.
 * The extension list is initialized once, and remains the same during the lifetime
 * of the CEP session.
 *
 * @param extensionIds  Optional, an array of unique identifiers for extensions of interest.
 *          If omitted, retrieves data for all extensions.
 *
 * @return Zero or more \c #Extension objects.
 */
CSInterface.prototype.getExtensions = function(extensionIds)
{
    var extensionIdsStr = JSON.stringify(extensionIds);
    var extensionsStr = window.__adobe_cep__.getExtensions(extensionIdsStr);

    var extensions = JSON.parse(extensionsStr);
    return extensions;
};

/**
 * Retrieves network-related preferences.
 *
 * @return A JavaScript object containing network preferences.
 */
CSInterface.prototype.getNetworkPreferences = function()
{
    var result = window.__adobe_cep__.getNetworkPreferences();
    var networkPre = JSON.parse(result);

    return networkPre;
};

/**
 * Initializes the resource bundle for this extension with property values
 * for the current application and locale.
 * To support multiple locales, you must define a property file for each locale,
 * containing keyed display-string values for that locale.
 * See localization documentation for Extension Builder and related products.
 *
 * Keys can be in the
 * form <code>key.value="localized string"</code>, for use in HTML text elements.
 * For example, in this input element, the localized \c key.value string is displayed
 * instead of the empty \c value string:
 *
 * <code><input type="submit" value="" data-locale="key"/></code>
 *
 * @return An object containing the resource bundle information.
 */
CSInterface.prototype.initResourceBundle = function()
{
    var resourceBundle = JSON.parse(window.__adobe_cep__.initResourceBundle());
    var resElms = document.querySelectorAll('[data-locale]');
    for (var n = 0; n < resElms.length; n++)
    {
       var resEl = resElms[n];
       // Get the resource key from the element.
       var resKey = resEl.getAttribute('data-locale');
       if (resKey)
       {
           // Get all the resources that start with the key.
           for (var key in resourceBundle)
           {
               if (key.indexOf(resKey) === 0)
               {
                   var resValue = resourceBundle[key];
                   if (key.length == resKey.length)
                   {
                        resEl.innerHTML = resValue;
                   }
                   else if ('.' == key.charAt(resKey.length))
                   {
                        var attrKey = key.substring(resKey.length + 1);
                        resEl[attrKey] = resValue;
                   }
               }
           }
       }
    }
    return resourceBundle;
};

/**
 * Writes installation information to a file.
 *
 * @return The file path.
 */
CSInterface.prototype.dumpInstallationInfo = function()
{
    return window.__adobe_cep__.dumpInstallationInfo();
};

/**
 * Retrieves version information for the current Operating System,
 * See http://www.useragentstring.com/pages/Chrome/ for Chrome \c navigator.userAgent values.
 *
 * @return A string containing the OS version, or "unknown Operation System".
 * If user customizes the User Agent by setting CEF command parameter "--user-agent", only
 * "Mac OS X" or "Windows" will be returned.
 */
CSInterface.prototype.getOSInformation = function()
{
    var userAgent = navigator.userAgent;

    if ((navigator.platform == "Win32") || (navigator.platform == "Windows"))
    {
        var winVersion = "Windows";
        var winBit = "";
        if (userAgent.indexOf("Windows") > -1)
        {
            if (userAgent.indexOf("Windows NT 5.0") > -1)
            {
                winVersion = "Windows 2000";
            }
            else if (userAgent.indexOf("Windows NT 5.1") > -1)
            {
                winVersion = "Windows XP";
            }
            else if (userAgent.indexOf("Windows NT 5.2") > -1)
            {
                winVersion = "Windows Server 2003";
            }
            else if (userAgent.indexOf("Windows NT 6.0") > -1)
            {
                winVersion = "Windows Vista";
            }
            else if (userAgent.indexOf("Windows NT 6.1") > -1)
            {
                winVersion = "Windows 7";
            }
            else if (userAgent.indexOf("Windows NT 6.2") > -1)
            {
                winVersion = "Windows 8";
            }
            else if (userAgent.indexOf("Windows NT 6.3") > -1)
            {
                winVersion = "Windows 8.1";
            }
            else if (userAgent.indexOf("Windows NT 10") > -1)
            {
                winVersion = "Windows 10";
            }

            if (userAgent.indexOf("WOW64") > -1 || userAgent.indexOf("Win64") > -1)
            {
                winBit = " 64-bit";
            }
            else
            {
                winBit = " 32-bit";
            }
        }

        return winVersion + winBit;
    }
    else if ((navigator.platform == "MacIntel") || (navigator.platform == "Macintosh"))
    {
        var result = "Mac OS X";

        if (userAgent.indexOf("Mac OS X") > -1)
        {
            result = userAgent.substring(userAgent.indexOf("Mac OS X"), userAgent.indexOf(")"));
            result = result.replace(/_/g, ".");
        }

        return result;
    }

    return "Unknown Operation System";
};

/**
 * Opens a page in the default system browser.
 *
 * Since 4.2.0
 *
 * @param url  The URL of the page/file to open, or the email address.
 * Must use HTTP/HTTPS/file/mailto protocol. For example:
 *   "http://www.adobe.com"
 *   "https://github.com"
 *   "file:///C:/log.txt"
 *   "mailto:test@adobe.com"
 *
 * @return One of these error codes:\n
 *      <ul>\n
 *          <li>NO_ERROR - 0</li>\n
 *          <li>ERR_UNKNOWN - 1</li>\n
 *          <li>ERR_INVALID_PARAMS - 2</li>\n
 *          <li>ERR_INVALID_URL - 201</li>\n
 *      </ul>\n
 */
CSInterface.prototype.openURLInDefaultBrowser = function(url)
{
    return cep.util.openURLInDefaultBrowser(url);
};

/**
 * Retrieves extension ID.
 *
 * Since 4.2.0
 *
 * @return extension ID.
 */
CSInterface.prototype.getExtensionID = function()
{
     return window.__adobe_cep__.getExtensionId();
};

/**
 * Retrieves the scale factor of screen.
 * On Windows platform, the value of scale factor might be different from operating system's scale factor,
 * since host application may use its self-defined scale factor.
 *
 * Since 4.2.0
 *
 * @return One of the following float number.
 *      <ul>\n
 *          <li> -1.0 when error occurs </li>\n
 *          <li> 1.0 means normal screen </li>\n
 *          <li> >1.0 means HiDPI screen </li>\n
 *      </ul>\n
 */
CSInterface.prototype.getScaleFactor = function()
{
    return window.__adobe_cep__.getScaleFactor();
};

/**
 * Retrieves the scale factor of Monitor.
 *
 * Since 8.5.0
 *
 * @return value >= 1.0f
 * only available for windows machine
 */
 if(navigator.appVersion.toLowerCase().indexOf("windows") >= 0) {
    CSInterface.prototype.getMonitorScaleFactor = function()
    {
        return window.__adobe_cep__.getMonitorScaleFactor();
    };
}

/**
 * Set a handler to detect any changes of scale factor. This only works on Mac.
 *
 * Since 4.2.0
 *
 * @param handler   The function to be called when scale factor is changed.
 *
 */
CSInterface.prototype.setScaleFactorChangedHandler = function(handler)
{
    window.__adobe_cep__.setScaleFactorChangedHandler(handler);
};

/**
 * Retrieves current API version.
 *
 * Since 4.2.0
 *
 * @return ApiVersion object.
 *
 */
CSInterface.prototype.getCurrentApiVersion = function()
{
    var apiVersion = JSON.parse(window.__adobe_cep__.getCurrentApiVersion());
    return apiVersion;
};

/**
 * Set panel flyout menu by an XML.
 *
 * Since 5.2.0
 *
 * Register a callback function for "com.adobe.csxs.events.flyoutMenuClicked" to get notified when a
 * menu item is clicked.
 * The "data" attribute of event is an object which contains "menuId" and "menuName" attributes.
 *
 * Register callback functions for "com.adobe.csxs.events.flyoutMenuOpened" and "com.adobe.csxs.events.flyoutMenuClosed"
 * respectively to get notified when flyout menu is opened or closed.
 *
 * @param menu     A XML string which describes menu structure.
 * An example menu XML:
 * <Menu>
 *   <MenuItem Id="menuItemId1" Label="TestExample1" Enabled="true" Checked="false"/>
 *   <MenuItem Label="TestExample2">
 *     <MenuItem Label="TestExample2-1" >
 *       <MenuItem Label="TestExample2-1-1" Enabled="false" Checked="true"/>
 *     </MenuItem>
 *     <MenuItem Label="TestExample2-2" Enabled="true" Checked="true"/>
 *   </MenuItem>
 *   <MenuItem Label="---" />
 *   <MenuItem Label="TestExample3" Enabled="false" Checked="false"/>
 * </Menu>
 *
 */
CSInterface.prototype.setPanelFlyoutMenu = function(menu)
{
    if ("string" != typeof menu)
    {
        return;
    }

    window.__adobe_cep__.invokeSync("setPanelFlyoutMenu", menu);
};

/**
 * Updates a menu item in the extension window's flyout menu, by setting the enabled
 * and selection status.
 *
 * Since 5.2.0
 *
 * @param menuItemLabel The menu item label.
 * @param enabled       True to enable the item, false to disable it (gray it out).
 * @param checked       True to select the item, false to deselect it.
 *
 * @return false when the host application does not support this functionality (HostCapabilities.EXTENDED_PANEL_MENU is false).
 *         Fails silently if menu label is invalid.
 *
 * @see HostCapabilities.EXTENDED_PANEL_MENU
 */
CSInterface.prototype.updatePanelMenuItem = function(menuItemLabel, enabled, checked)
{
    var ret = false;
    if (this.getHostCapabilities().EXTENDED_PANEL_MENU)
    {
        var itemStatus = new MenuItemStatus(menuItemLabel, enabled, checked);
        ret = window.__adobe_cep__.invokeSync("updatePanelMenuItem", JSON.stringify(itemStatus));
    }
    return ret;
};


/**
 * Set context menu by XML string.
 *
 * Since 5.2.0
 *
 * There are a number of conventions used to communicate what type of menu item to create and how it should be handled.
 * - an item without menu ID or menu name is disabled and is not shown.
 * - if the item name is "---" (three hyphens) then it is treated as a separator. The menu ID in this case will always be NULL.
 * - Checkable attribute takes precedence over Checked attribute.
 * - a PNG icon. For optimal display results please supply a 16 x 16px icon as larger dimensions will increase the size of the menu item.
     The Chrome extension contextMenus API was taken as a reference.
     https://developer.chrome.com/extensions/contextMenus
 * - the items with icons and checkable items cannot coexist on the same menu level. The former take precedences over the latter.
 *
 * @param menu      A XML string which describes menu structure.
 * @param callback  The callback function which is called when a menu item is clicked. The only parameter is the returned ID of clicked menu item.
 *
 * @description An example menu XML:
 * <Menu>
 *   <MenuItem Id="menuItemId1" Label="TestExample1" Enabled="true" Checkable="true" Checked="false" Icon="./image/small_16X16.png"/>
 *   <MenuItem Id="menuItemId2" Label="TestExample2">
 *     <MenuItem Id="menuItemId2-1" Label="TestExample2-1" >
 *       <MenuItem Id="menuItemId2-1-1" Label="TestExample2-1-1" Enabled="false" Checkable="true" Checked="true"/>
 *     </MenuItem>
 *     <MenuItem Id="menuItemId2-2" Label="TestExample2-2" Enabled="true" Checkable="true" Checked="true"/>
 *   </MenuItem>
 *   <MenuItem Label="---" />
 *   <MenuItem Id="menuItemId3" Label="TestExample3" Enabled="false" Checkable="true" Checked="false"/>
 * </Menu>
 */
CSInterface.prototype.setContextMenu = function(menu, callback)
{
    if ("string" != typeof menu)
    {
        return;
    }

    window.__adobe_cep__.invokeAsync("setContextMenu", menu, callback);
};

/**
 * Set context menu by JSON string.
 *
 * Since 6.0.0
 *
 * There are a number of conventions used to communicate what type of menu item to create and how it should be handled.
 * - an item without menu ID or menu name is disabled and is not shown.
 * - if the item label is "---" (three hyphens) then it is treated as a separator. The menu ID in this case will always be NULL.
 * - Checkable attribute takes precedence over Checked attribute.
 * - a PNG icon. For optimal display results please supply a 16 x 16px icon as larger dimensions will increase the size of the menu item.
     The Chrome extension contextMenus API was taken as a reference.
 * - the items with icons and checkable items cannot coexist on the same menu level. The former take precedences over the latter.
     https://developer.chrome.com/extensions/contextMenus
 *
 * @param menu      A JSON string which describes menu structure.
 * @param callback  The callback function which is called when a menu item is clicked. The only parameter is the returned ID of clicked menu item.
 *
 * @description An example menu JSON:
 *
 * {
 *      "menu": [
 *          {
 *              "id": "menuItemId1",
 *              "label": "testExample1",
 *              "enabled": true,
 *              "checkable": true,
 *              "checked": false,
 *              "icon": "./image/small_16X16.png"
 *          },
 *          {
 *              "id": "menuItemId2",
 *              "label": "testExample2",
 *              "menu": [
 *                  {
 *                      "id": "menuItemId2-1",
 *                      "label": "testExample2-1",
 *                      "menu": [
 *                          {
 *                              "id": "menuItemId2-1-1",
 *                              "label": "testExample2-1-1",
 *                              "enabled": false,
 *                              "checkable": true,
 *                              "checked": true
 *                          }
 *                      ]
 *                  },
 *                  {
 *                      "id": "menuItemId2-2",
 *                      "label": "testExample2-2",
 *                      "enabled": true,
 *                      "checkable": true,
 *                      "checked": true
 *                  }
 *              ]
 *          },
 *          {
 *              "label": "---"
 *          },
 *          {
 *              "id": "menuItemId3",
 *              "label": "testExample3",
 *              "enabled": false,
 *              "checkable": true,
 *              "checked": false
 *          }
 *      ]
 *  }
 *
 */
CSInterface.prototype.setContextMenuByJSON = function(menu, callback)
{
    if ("string" != typeof menu)
    {
        return;
    }

    window.__adobe_cep__.invokeAsync("setContextMenuByJSON", menu, callback);
};

/**
 * Updates a context menu item by setting the enabled and selection status.
 *
 * Since 5.2.0
 *
 * @param menuItemID    The menu item ID.
 * @param enabled       True to enable the item, false to disable it (gray it out).
 * @param checked       True to select the item, false to deselect it.
 */
CSInterface.prototype.updateContextMenuItem = function(menuItemID, enabled, checked)
{
    var itemStatus = new ContextMenuItemStatus(menuItemID, enabled, checked);
    ret = window.__adobe_cep__.invokeSync("updateContextMenuItem", JSON.stringify(itemStatus));
};

/**
 * Get the visibility status of an extension window.
 *
 * Since 6.0.0
 *
 * @return true if the extension window is visible; false if the extension window is hidden.
 */
CSInterface.prototype.isWindowVisible = function()
{
    return window.__adobe_cep__.invokeSync("isWindowVisible", "");
};

/**
 * Resize extension's content to the specified dimensions.
 * 1. Works with modal and modeless extensions in all Adobe products.
 * 2. Extension's manifest min/max size constraints apply and take precedence.
 * 3. For panel extensions
 *    3.1 This works in all Adobe products except:
 *        * Premiere Pro
 *        * Prelude
 *        * After Effects
 *    3.2 When the panel is in certain states (especially when being docked),
 *        it will not change to the desired dimensions even when the
 *        specified size satisfies min/max constraints.
 *
 * Since 6.0.0
 *
 * @param width  The new width
 * @param height The new height
 */
CSInterface.prototype.resizeContent = function(width, height)
{
    window.__adobe_cep__.resizeContent(width, height);
};

/**
 * Register the invalid certificate callback for an extension.
 * This callback will be triggered when the extension tries to access the web site that contains the invalid certificate on the main frame.
 * But if the extension does not call this function and tries to access the web site containing the invalid certificate, a default error page will be shown.
 *
 * Since 6.1.0
 *
 * @param callback the callback function
 */
CSInterface.prototype.registerInvalidCertificateCallback = function(callback)
{
    return window.__adobe_cep__.registerInvalidCertificateCallback(callback);
};

/**
 * Register an interest in some key events to prevent them from being sent to the host application.
 *
 * This function works with modeless extensions and panel extensions.
 * Generally all the key events will be sent to the host application for these two extensions if the current focused element
 * is not text input or dropdown,
 * If you want to intercept some key events and want them to be handled in the extension, please call this function
 * in advance to prevent them being sent to the host application.
 *
 * Since 6.1.0
 *
 * @param keyEventsInterest      A JSON string describing those key events you are interested in. A null object or
                                 an empty string will lead to removing the interest
 *
 * This JSON string should be an array, each object has following keys:
 *
 * keyCode:  [Required] represents an OS system dependent virtual key code identifying
 *           the unmodified value of the pressed key.
 * ctrlKey:  [optional] a Boolean that indicates if the control key was pressed (true) or not (false) when the event occurred.
 * altKey:   [optional] a Boolean that indicates if the alt key was pressed (true) or not (false) when the event occurred.
 * shiftKey: [optional] a Boolean that indicates if the shift key was pressed (true) or not (false) when the event occurred.
 * metaKey:  [optional] (Mac Only) a Boolean that indicates if the Meta key was pressed (true) or not (false) when the event occurred.
 *                      On Macintosh keyboards, this is the command key. To detect Windows key on Windows, please use keyCode instead.
 * An example JSON string:
 *
 * [
 *     {
 *         "keyCode": 48
 *     },
 *     {
 *         "keyCode": 123,
 *         "ctrlKey": true
 *     },
 *     {
 *         "keyCode": 123,
 *         "ctrlKey": true,
 *         "metaKey": true
 *     }
 * ]
 *
 */
CSInterface.prototype.registerKeyEventsInterest = function(keyEventsInterest)
{
    return window.__adobe_cep__.registerKeyEventsInterest(keyEventsInterest);
};

/**
 * Set the title of the extension window.
 * This function works with modal and modeless extensions in all Adobe products, and panel extensions in Photoshop, InDesign, InCopy, Illustrator, Flash Pro and Dreamweaver.
 *
 * Since 6.1.0
 *
 * @param title The window title.
 */
CSInterface.prototype.setWindowTitle = function(title)
{
    window.__adobe_cep__.invokeSync("setWindowTitle", title);
};

/**
 * Get the title of the extension window.
 * This function works with modal and modeless extensions in all Adobe products, and panel extensions in Photoshop, InDesign, InCopy, Illustrator, Flash Pro and Dreamweaver.
 *
 * Since 6.1.0
 *
 * @return The window title.
 */
CSInterface.prototype.getWindowTitle = function()
{
    return window.__adobe_cep__.invokeSync("getWindowTitle", "");
};
</file>

<file path="index-metadata.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EAV Ingest Assistant - Metadata</title>
    <link rel="stylesheet" href="css/metadata-panel.css">
</head>
<body>
    <!-- Metadata Panel: Form (80%) | Debug Panel (20%) -->
    <div id="app" class="metadata-panel-container">

        <!-- LEFT: METADATA FORM (80%) -->
        <div class="metadata-form-section">
            <!-- Form Header -->
            <div class="form-header">
                <h3>Metadata Editor</h3>
                <span id="formClipName" class="form-clip-name">No clip selected</span>
            </div>

            <!-- Form Content -->
            <div class="form-content">
                <!-- Top Row: Identifier (20%) | Description (70%) | Good (10%) -->
                <div class="form-row-split">
                    <!-- Identifier (20%) -->
                    <div class="form-group-split" style="flex: 20;">
                        <label for="metadataTapeName">Identifier</label>
                        <input
                            type="text"
                            id="metadataTapeName"
                            readonly
                            class="readonly-field"
                            placeholder="Clip identifier"
                        />
                    </div>

                    <!-- Description (70%) -->
                    <div class="form-group-split" style="flex: 70;">
                        <label for="metadataDescription">Description (Metadata Tags)</label>
                        <input
                            type="text"
                            id="metadataDescription"
                            placeholder="e.g. kitchen, modern, before-renovation, wide-angle"
                        />
                    </div>

                    <!-- Good Checkbox (10%) -->
                    <div class="form-group-split form-group-checkbox" style="flex: 10;">
                        <label for="metadataGood">Good</label>
                        <input
                            type="checkbox"
                            id="metadataGood"
                            class="checkbox-good"
                        />
                    </div>
                </div>

                <!-- Single Line: Location | Subject | Action | Shot Type -->
                <div class="form-row">
                    <!-- Location -->
                    <div class="form-group-inline">
                        <label for="metadataLocation">Location</label>
                        <input
                            type="text"
                            id="metadataLocation"
                            placeholder="e.g. kitchen"
                            list="locationList"
                        />
                        <datalist id="locationList">
                            <option value="kitchen">
                            <option value="bathroom">
                            <option value="bedroom">
                            <option value="living-room">
                            <option value="exterior">
                        </datalist>
                    </div>

                    <!-- Subject -->
                    <div class="form-group-inline">
                        <label for="metadataSubject">Subject</label>
                        <input
                            type="text"
                            id="metadataSubject"
                            placeholder="e.g. oven"
                            list="subjectList"
                        />
                        <datalist id="subjectList">
                            <option value="sink">
                            <option value="oven">
                            <option value="window">
                            <option value="door">
                            <option value="countertop">
                        </datalist>
                    </div>

                    <!-- Action (videos only) -->
                    <div class="form-group-inline" id="actionGroup">
                        <label for="metadataAction">Action</label>
                        <input
                            type="text"
                            id="metadataAction"
                            placeholder="e.g. cleaning"
                            list="actionList"
                        />
                        <datalist id="actionList">
                            <option value="cleaning">
                            <option value="installing">
                            <option value="repairing">
                            <option value="painting">
                            <option value="demolishing">
                        </datalist>
                    </div>

                    <!-- Shot Type (Restricted Searchable Dropdown) -->
                    <div class="form-group-inline">
                        <label for="metadataShotType">Shot Type</label>
                        <div class="searchable-dropdown">
                            <input
                                type="text"
                                id="metadataShotType"
                                placeholder="Type to search..."
                                autocomplete="off"
                                class="searchable-input"
                            />
                            <div id="shotTypeDropdown" class="dropdown-list" style="display: none;">
                                <div class="dropdown-option" data-value="WS">WS (Wide Shot)</div>
                                <div class="dropdown-option" data-value="MID">MID (Medium Shot)</div>
                                <div class="dropdown-option" data-value="CU">CU (Close Up)</div>
                                <div class="dropdown-option" data-value="UNDER">UNDER (Underslung)</div>
                                <div class="dropdown-option" data-value="FP">FP (First Person)</div>
                                <div class="dropdown-option" data-value="TRACK">TRACK (Tracking Shot)</div>
                                <div class="dropdown-option" data-value="ESTAB">ESTAB (Establishing)</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Generated Name Preview -->
                <div class="name-preview">
                    <label>Generated Name:</label>
                    <div id="generatedName" class="generated-name-text">-</div>
                </div>
            </div>

            <!-- Form Actions -->
            <div class="form-actions">
                <div class="nav-buttons-row">
                    <button id="prevBtn" class="btn-nav" disabled> Previous</button>
                    <button id="applyBtn" class="btn-primary" disabled>Apply to Premiere</button>
                    <button id="nextBtn" class="btn-nav" disabled>Next </button>
                </div>
            </div>

            <!-- Status Messages -->
            <div id="formStatus" class="form-status"></div>
        </div>

        <!-- RIGHT: DEBUG PANEL (20%) -->
        <div class="debug-panel-section" id="debugPanel">
            <div class="debug-header">
                <span class="debug-title">Diagnostics</span>
                <button id="clearDebug" class="icon-btn-small" title="Clear log">Clear</button>
            </div>
            <div class="debug-content" id="debugContent">
                <div class="debug-line">
                    <span class="debug-time">00:00:00</span>
                    <span class="debug-message">Metadata Panel initialized</span>
                </div>
            </div>
        </div>

    </div>

    <!-- Load CEP Interface Library -->
    <script type="text/javascript" src="js/CSInterface.js"></script>
    <script type="text/javascript" src="js/metadata-panel.js"></script>
</body>
</html>
</file>

<file path="test-cep-load.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CEP Load Test</title>
    <style>
        body {
            font-family: monospace;
            background-color: #1e1e1e;
            color: #d0d0d0;
            padding: 20px;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .pass { background-color: #1a472a; }
        .fail { background-color: #5a1a1a; }
    </style>
</head>
<body>
    <h1>CEP Script Load Test</h1>
    <div id="results"></div>

    <!-- Load CSInterface first -->
    <script type="text/javascript" src="js/CSInterface.js"></script>

    <!-- Test Script -->
    <script type="text/javascript">
        (function() {
            var results = document.getElementById('results');

            function addResult(name, passed, message) {
                var div = document.createElement('div');
                div.className = 'test-result ' + (passed ? 'pass' : 'fail');
                div.innerHTML = '<strong>' + (passed ? '' : '') + ' ' + name + ':</strong> ' + message;
                results.appendChild(div);
            }

            // Test 1: CSInterface loaded
            if (typeof CSInterface !== 'undefined') {
                addResult('CSInterface Loaded', true, 'CSInterface class is defined');

                // Test 2: Can instantiate
                try {
                    var csInterface = new CSInterface();
                    addResult('CSInterface Instantiation', true, 'CSInterface instance created');

                    // Test 3: Can get system path
                    try {
                        var extensionPath = csInterface.getSystemPath('extension');
                        addResult('System Path API', true, 'Extension path: ' + extensionPath);
                    } catch (e) {
                        addResult('System Path API', false, e.message);
                    }

                    // Test 4: Can call ExtendScript
                    try {
                        csInterface.evalScript('1 + 1', function(result) {
                            addResult('ExtendScript Eval', true, 'Result: ' + result);
                        });
                    } catch (e) {
                        addResult('ExtendScript Eval', false, e.message);
                    }

                } catch (e) {
                    addResult('CSInterface Instantiation', false, e.message);
                }
            } else {
                addResult('CSInterface Loaded', false, 'CSInterface is undefined - file not loaded or execution error');
            }

            // Test 5: DOM Ready
            addResult('DOM Ready', true, 'Document loaded and executing');

            // Test 6: Console availability
            if (typeof console !== 'undefined' && console.log) {
                addResult('Console Available', true, 'console.log is available');
                console.log('[CEP Test] Console is working');
            } else {
                addResult('Console Available', false, 'console.log is not available');
            }
        })();
    </script>
</body>
</html>
</file>

<file path="css/navigation-panel.css">
/* Navigation Panel - Clip Browser (75%) + Debug Panel (25%) */

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 12px;
    color: #d0d0d0;
    background-color: #1e1e1e;
    overflow: hidden;
}

/* ========================================
   MAIN CONTAINER: Vertical Split
   ======================================== */

.navigation-panel-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
}

/* ========================================
   TOP SECTION: CLIP BROWSER (75%)
   ======================================== */

.clip-browser-section {
    flex: 75%;
    background-color: #252525;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Search Bar */
.search-bar {
    display: flex;
    gap: 4px;
    padding: 8px;
    background-color: #2b2b2b;
    border-bottom: 1px solid #3a3a3a;
}

.search-bar input {
    flex: 1;
    padding: 6px 8px;
    background-color: #1e1e1e;
    border: 1px solid #404040;
    border-radius: 4px;
    color: #d0d0d0;
    font-size: 12px;
}

.search-bar input:focus {
    outline: none;
    border-color: #0078d4;
}

.search-bar .icon-btn {
    padding: 6px 8px;
    background-color: #3a3a3a;
    border: none;
    border-radius: 4px;
    color: #d0d0d0;
    cursor: pointer;
    font-size: 12px;
}

.search-bar .icon-btn:hover {
    background-color: #404040;
}

/* Filters */
.filters {
    display: flex;
    gap: 12px;
    padding: 8px;
    background-color: #2b2b2b;
    border-bottom: 1px solid #3a3a3a;
    font-size: 11px;
}

.filter-checkbox {
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    user-select: none;
}

.filter-checkbox input[type="checkbox"] {
    cursor: pointer;
}

/* Sort Row */
.sort-row {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    background-color: #2b2b2b;
    border-bottom: 1px solid #3a3a3a;
}

.sort-row label {
    font-size: 11px;
    color: #ccc;
    flex-shrink: 0;
}

.sort-dropdown {
    flex: 1;
    padding: 4px 8px;
    background-color: #1e1e1e;
    border: 1px solid #404040;
    border-radius: 4px;
    color: #d0d0d0;
    font-size: 11px;
    cursor: pointer;
}

.sort-dropdown:focus {
    outline: none;
    border-color: #0078d4;
}

/* Batch Controls */
.batch-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
    padding: 8px;
    background-color: #2b2b2b;
    border-bottom: 1px solid #3a3a3a;
}

.batch-selection {
    display: flex;
    align-items: center;
    gap: 8px;
}

.batch-btn-small {
    padding: 4px 8px;
    background-color: #3a3a3a;
    border: 1px solid #404040;
    border-radius: 4px;
    color: #d0d0d0;
    cursor: pointer;
    font-size: 11px;
    transition: background-color 0.15s;
}

.batch-btn-small:hover {
    background-color: #404040;
}

.selected-count {
    font-size: 11px;
    color: #808080;
    padding-left: 4px;
    font-weight: 500;
}

.batch-apply-btn {
    padding: 6px 12px;
    background-color: #0078d4;
    border: none;
    border-radius: 4px;
    color: #fff;
    cursor: pointer;
    font-size: 12px;
    font-weight: 500;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: background-color 0.15s;
}

.batch-apply-btn:hover:not(:disabled) {
    background-color: #0063b1;
}

.batch-apply-btn:disabled {
    background-color: #404040;
    color: #808080;
    cursor: not-allowed;
}

.batch-apply-btn.processing {
    background-color: #ffa500;
}

.batch-icon {
    font-size: 14px;
}

/* Bin Headers */
.bin-header {
    padding: 8px 12px;
    background-color: #3a3a3a;
    border-left: 3px solid #0078d4;
    border-bottom: 1px solid #2b2b2b;
    font-weight: bold;
    font-size: 11px;
    color: #e0e0e0;
    cursor: default;
    user-select: none;
}

.bin-header::before {
    content: ' ';
    margin-right: 6px;
}

/* Clip items under bins */
.clip-item.in-bin {
    padding-left: 32px;
}

/* Clip List */
.clip-list {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
}

.clip-list-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: #808080;
    text-align: center;
    padding: 20px;
}

.clip-list-empty .hint {
    font-size: 11px;
    margin-top: 8px;
}

.clip-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    border-bottom: 1px solid #2b2b2b;
    cursor: pointer;
    transition: background-color 0.15s;
}

.clip-item:hover {
    background-color: #2b2b2b;
}

.clip-item.selected {
    background-color: #094771;
}

.clip-item.selected:hover {
    background-color: #0d5a8f;
}

.clip-item.checked {
    background-color: #2d4a2d;
}

.clip-item.checked:hover {
    background-color: #345334;
}

.clip-checkbox {
    width: 16px;
    height: 16px;
    cursor: pointer;
    flex-shrink: 0;
}

.status-icon {
    font-size: 14px;
    width: 16px;
    text-align: center;
}

.status-icon.tagged {
    color: #4ec9b0; /* Green checkmark */
}

.status-icon.untagged {
    color: #808080; /* Gray dot */
}

.clip-name {
    flex: 1;
    font-size: 11px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.clip-duration {
    font-size: 10px;
    color: #808080;
}

/* Footer */
.clip-browser-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px;
    background-color: #2b2b2b;
    border-top: 1px solid #3a3a3a;
    font-size: 11px;
    color: #808080;
}

.clip-browser-footer .icon-btn {
    padding: 4px 6px;
    background-color: transparent;
    border: none;
    color: #d0d0d0;
    cursor: pointer;
    border-radius: 4px;
}

.clip-browser-footer .icon-btn:hover {
    background-color: #3a3a3a;
}

/* ========================================
   BOTTOM SECTION: DEBUG PANEL (25%)
   ======================================== */

.debug-panel-section {
    flex: 25%;
    background-color: #1a1a1a;
    border-top: 2px solid #0f0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.debug-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 6px 8px;
    background-color: #0a0a0a;
    border-bottom: 1px solid #0f0;
}

.debug-title {
    font-family: 'Courier New', monospace;
    font-size: 11px;
    color: #0f0;
    font-weight: 600;
    text-transform: uppercase;
}

.icon-btn-small {
    padding: 2px 6px;
    background-color: transparent;
    border: 1px solid #0f0;
    border-radius: 3px;
    color: #0f0;
    cursor: pointer;
    font-size: 10px;
    font-family: 'Courier New', monospace;
}

.icon-btn-small:hover {
    background-color: #0f0;
    color: #000;
}

.debug-content {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
    font-family: 'Courier New', monospace;
    font-size: 10px;
    line-height: 1.4;
}

.debug-line {
    display: flex;
    gap: 8px;
    margin-bottom: 2px;
    padding: 2px 4px;
}

.debug-line.error {
    background-color: rgba(255, 0, 0, 0.1);
}

.debug-time {
    color: #666;
    flex-shrink: 0;
}

.debug-message {
    color: #0f0;
    word-break: break-word;
}

.debug-line.error .debug-message {
    color: #f00;
}

/* ========================================
   SCROLLBAR STYLING
   ======================================== */

::-webkit-scrollbar {
    width: 12px;
    height: 12px;
}

::-webkit-scrollbar-track {
    background: #1e1e1e;
}

::-webkit-scrollbar-thumb {
    background: #404040;
    border-radius: 6px;
}

::-webkit-scrollbar-thumb:hover {
    background: #505050;
}

/* Debug panel scrollbar - green theme */
.debug-content::-webkit-scrollbar-thumb {
    background: #0f0;
}

.debug-content::-webkit-scrollbar-thumb:hover {
    background: #0c0;
}
</file>

<file path="css/panel-layout.css">
/* Three-Panel CEP Layout - Self-Contained Architecture */

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 12px;
    color: #d0d0d0;
    background-color: #1e1e1e;
    overflow: hidden;
}

/* ========================================
   MAIN GRID LAYOUT
   ======================================== */

.panel-container {
    display: grid;
    grid-template-columns: 280px 1fr; /* ClipBrowser | RightPanel */
    grid-template-rows: 1fr;
    height: 100vh;
    width: 100vw;
    gap: 0;
    overflow: hidden;
}

/* ========================================
   LEFT PANEL: CLIP BROWSER
   ======================================== */

.clip-browser {
    grid-column: 1;
    background-color: #252525;
    border-right: 1px solid #3a3a3a;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Search Bar */
.search-bar {
    display: flex;
    gap: 4px;
    padding: 8px;
    background-color: #2b2b2b;
    border-bottom: 1px solid #3a3a3a;
}

.search-bar input {
    flex: 1;
    padding: 6px 8px;
    background-color: #1e1e1e;
    border: 1px solid #404040;
    border-radius: 4px;
    color: #d0d0d0;
    font-size: 12px;
}

.search-bar input:focus {
    outline: none;
    border-color: #0078d4;
}

.search-bar .icon-btn {
    padding: 6px 8px;
    background-color: #3a3a3a;
    border: none;
    border-radius: 4px;
    color: #d0d0d0;
    cursor: pointer;
    font-size: 12px;
}

.search-bar .icon-btn:hover {
    background-color: #404040;
}

/* Filters */
.filters {
    display: flex;
    gap: 12px;
    padding: 8px;
    background-color: #2b2b2b;
    border-bottom: 1px solid #3a3a3a;
    font-size: 11px;
}

.filter-checkbox {
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    user-select: none;
}

.filter-checkbox input[type="checkbox"] {
    cursor: pointer;
}

/* Clip List */
.clip-list {
    flex: 1;
    overflow-y: auto;
    overflow-x: hidden;
}

.clip-list-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: #808080;
    text-align: center;
    padding: 20px;
}

.clip-list-empty .hint {
    font-size: 11px;
    margin-top: 8px;
}

.clip-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px;
    border-bottom: 1px solid #2b2b2b;
    cursor: pointer;
    transition: background-color 0.15s;
}

.clip-item:hover {
    background-color: #2b2b2b;
}

.clip-item.selected {
    background-color: #094771;
}

.clip-item.selected:hover {
    background-color: #0d5a8f;
}

.status-icon {
    font-size: 14px;
    width: 16px;
    text-align: center;
}

.status-icon.tagged {
    color: #4ec9b0; /* Green checkmark */
}

.status-icon.untagged {
    color: #808080; /* Gray dot */
}

.clip-name {
    flex: 1;
    font-size: 11px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.clip-duration {
    font-size: 10px;
    color: #808080;
}

/* Footer */
.clip-browser-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px;
    background-color: #2b2b2b;
    border-top: 1px solid #3a3a3a;
    font-size: 11px;
    color: #808080;
}

.clip-browser-footer .icon-btn {
    padding: 4px 6px;
    background-color: transparent;
    border: none;
    color: #d0d0d0;
    cursor: pointer;
    border-radius: 4px;
}

.clip-browser-footer .icon-btn:hover {
    background-color: #3a3a3a;
}

/* ========================================
   RIGHT PANEL: CONTAINER FOR THUMBNAIL + METADATA
   ======================================== */

.right-panel-container {
    grid-column: 2;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* ========================================
   TOP SECTION: THUMBNAIL VIEWER
   ======================================== */

.thumbnail-viewer {
    flex: 1;
    background-color: #1e1e1e;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border-bottom: 1px solid #3a3a3a;
}

/* Thumbnail Container */
.thumbnail-container {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #0d0d0d;
    border: 1px solid #2b2b2b;
    margin: 16px;
    border-radius: 4px;
    overflow: hidden;
    position: relative;
}

.thumbnail-placeholder {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    color: #606060;
    text-align: center;
}

.thumbnail-placeholder svg {
    margin-bottom: 12px;
}

.thumbnail-placeholder p {
    font-size: 13px;
}

.thumbnail-image {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
}

/* Clip Info Bar */
.thumbnail-info {
    padding: 12px 16px;
    background-color: #252525;
    border-top: 1px solid #3a3a3a;
    border-bottom: 1px solid #3a3a3a;
}

.thumbnail-clip-name {
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 4px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.thumbnail-clip-details {
    font-size: 11px;
    color: #808080;
}

/* Action Buttons */
.thumbnail-actions {
    padding: 12px 16px;
    display: flex;
    gap: 8px;
    justify-content: center;
}

.btn-secondary {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 16px;
    background-color: #3a3a3a;
    border: 1px solid #505050;
    border-radius: 4px;
    color: #d0d0d0;
    font-size: 12px;
    cursor: pointer;
    transition: background-color 0.15s;
}

.btn-secondary:hover:not(:disabled) {
    background-color: #404040;
}

.btn-secondary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Status Messages */
.thumbnail-status {
    padding: 8px 16px;
    font-size: 11px;
    text-align: center;
    min-height: 28px;
}

.thumbnail-status.info {
    color: #4fc3f7;
}

.thumbnail-status.success {
    color: #4ec9b0;
}

.thumbnail-status.error {
    color: #f48771;
}

/* ========================================
   BOTTOM SECTION: METADATA FORM
   ======================================== */

.metadata-form {
    flex: 0 0 auto;
    max-height: 45vh;
    background-color: #252525;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* Form Header */
.form-header {
    padding: 12px 16px;
    background-color: #2b2b2b;
    border-bottom: 1px solid #3a3a3a;
}

.form-header h3 {
    font-size: 13px;
    font-weight: 600;
    margin-bottom: 4px;
}

.form-clip-name {
    font-size: 11px;
    color: #808080;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    display: block;
}

/* Form Content */
.form-content {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
}

.form-group {
    margin-bottom: 16px;
}

.form-group label {
    display: block;
    font-size: 11px;
    font-weight: 600;
    margin-bottom: 4px;
    color: #b0b0b0;
}

.form-group input[type="text"],
.form-group select {
    width: 100%;
    padding: 6px 8px;
    background-color: #1e1e1e;
    border: 1px solid #404040;
    border-radius: 4px;
    color: #d0d0d0;
    font-size: 12px;
}

.form-group input[type="text"]:focus,
.form-group select:focus {
    outline: none;
    border-color: #0078d4;
}

.form-group input.readonly-field {
    background-color: #2b2b2b;
    color: #808080;
    cursor: not-allowed;
}

.form-group small {
    display: block;
    font-size: 10px;
    color: #808080;
    margin-top: 4px;
}

/* Generated Name Preview */
.name-preview {
    margin-top: 16px;
    padding: 12px;
    background-color: #2b2b2b;
    border-radius: 4px;
}

.name-preview label {
    display: block;
    font-size: 11px;
    font-weight: 600;
    margin-bottom: 6px;
    color: #b0b0b0;
}

.generated-name-text {
    font-size: 13px;
    color: #4ec9b0;
    font-family: 'Courier New', monospace;
    word-break: break-all;
}

/* Form Actions */
.form-actions {
    padding: 16px;
    background-color: #2b2b2b;
    border-top: 1px solid #3a3a3a;
}

.nav-buttons {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
}

.btn-nav {
    flex: 1;
    padding: 10px 12px;
    background-color: #3a3a3a;
    border: 1px solid #505050;
    border-radius: 4px;
    color: #d0d0d0;
    font-size: 12px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.15s;
}

.btn-nav:hover:not(:disabled) {
    background-color: #454545;
    border-color: #606060;
}

.btn-nav:disabled {
    opacity: 0.4;
    cursor: not-allowed;
}

.btn-primary {
    width: 100%;
    padding: 12px;
    background-color: #0078d4;
    border: none;
    border-radius: 4px;
    color: #ffffff;
    font-size: 13px;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.15s;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.btn-primary:hover:not(:disabled) {
    background-color: #005a9e;
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
}

.btn-primary:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
}

/* Form Status Messages */
.form-status {
    padding: 8px 16px;
    font-size: 11px;
    text-align: center;
    min-height: 28px;
}

.form-status.info {
    color: #4fc3f7;
}

.form-status.success {
    color: #4ec9b0;
}

.form-status.error {
    color: #f48771;
}

/* ========================================
   SCROLLBAR STYLING
   ======================================== */

::-webkit-scrollbar {
    width: 12px;
    height: 12px;
}

::-webkit-scrollbar-track {
    background: #1e1e1e;
}

::-webkit-scrollbar-thumb {
    background: #404040;
    border-radius: 6px;
}

::-webkit-scrollbar-thumb:hover {
    background: #505050;
}

/* ========================================
   RESPONSIVE BREAKPOINTS
   ======================================== */

/* Narrow panel (900-1199px) */
@media (max-width: 1199px) {
    .panel-container {
        grid-template-columns: 250px 1fr;
    }
}

/* Collapse clip browser (< 900px) */
@media (max-width: 899px) {
    .clip-browser {
        display: none;
    }

    .panel-container {
        grid-template-columns: 1fr;
    }

    .metadata-form {
        max-height: 50vh;
    }
}
</file>

<file path="index-navigation.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EAV Ingest Assistant - Navigation</title>
    <link rel="stylesheet" href="css/navigation-panel.css">
</head>
<body>
    <!-- Navigation Panel: Clip List (75%) + Debug Panel (25%) -->
    <div id="app" class="navigation-panel-container">

        <!-- TOP: CLIP BROWSER (75%) -->
        <div class="clip-browser-section">
            <!-- Search Bar -->
            <div class="search-bar">
                <input
                    type="text"
                    id="clipSearch"
                    placeholder="Search clips..."
                    aria-label="Search clips"
                />
                <button id="clearSearch" class="icon-btn" aria-label="Clear search"></button>
            </div>

            <!-- Filters -->
            <div class="filters">
                <label class="filter-checkbox">
                    <input type="checkbox" id="filterVideo" checked>
                    Video
                </label>
                <label class="filter-checkbox">
                    <input type="checkbox" id="filterImage" checked>
                    Image
                </label>
                <label class="filter-checkbox">
                    <input type="checkbox" id="filterHasMeta">
                    Tagged
                </label>
            </div>

            <!-- Sort Dropdown -->
            <div class="sort-row">
                <label for="sortBy">Sort:</label>
                <select id="sortBy" class="sort-dropdown">
                    <option value="name">Name (A-Z)</option>
                    <option value="name-desc">Name (Z-A)</option>
                    <option value="bin" selected>By Bin</option>
                </select>
            </div>

            <!-- Batch Selection Controls -->
            <div class="batch-controls">
                <div class="batch-selection">
                    <button id="selectAll" class="batch-btn-small">Select All</button>
                    <button id="selectNone" class="batch-btn-small">Clear</button>
                    <span id="selectedCount" class="selected-count">0 selected</span>
                </div>
                <button id="batchApply" class="batch-apply-btn" disabled title="Apply XMP metadata to selected clips in Premiere Pro (Cmd+Shift+A)">
                    <span class="batch-icon"></span> Batch Apply to Premiere
                </button>
            </div>

            <!-- Clip List -->
            <div class="clip-list" id="clipList" role="list">
                <!-- Dynamically generated clip items will go here -->
                <div class="clip-list-empty">
                    <p>No project loaded</p>
                    <p class="hint">Open a Premiere Pro project</p>
                </div>
            </div>

            <!-- Footer with count -->
            <div class="clip-browser-footer">
                <span id="clipCount">0 clips</span>
                <button id="refreshClips" class="icon-btn" title="Refresh clips">
                    <svg width="14" height="14" viewBox="0 0 16 16">
                        <path fill="currentColor" d="M13.65 2.35C12.2 0.9 10.21 0 8 0 3.58 0 0 3.58 0 8s3.58 8 8 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L9 7h7V0l-2.35 2.35z"/>
                    </svg>
                </button>
            </div>
        </div>

        <!-- BOTTOM: DEBUG PANEL (25%) -->
        <div class="debug-panel-section" id="debugPanel">
            <div class="debug-header">
                <span class="debug-title">Diagnostics</span>
                <button id="clearDebug" class="icon-btn-small" title="Clear log">Clear</button>
            </div>
            <div class="debug-content" id="debugContent">
                <div class="debug-line">
                    <span class="debug-time">00:00:00</span>
                    <span class="debug-message">Navigation Panel initialized</span>
                </div>
            </div>
        </div>

    </div>

    <!-- Load CEP Interface Library -->
    <script type="text/javascript" src="js/CSInterface.js"></script>
    <script type="text/javascript" src="js/navigation-panel.js"></script>
</body>
</html>
</file>

<file path="js/main.js">
/**

 * EAV Ingest Assistant - CEP Panel Logic

 * Handles UI interactions and communication with Premiere Pro via ExtendScript

 */



(function() {

  'use strict';

  // ========================================
  // SECURITY: String escaping for evalScript
  // ========================================

  /**
     * Escape a string for safe use in evalScript string concatenation
     * Prevents code injection by escaping quotes and backslashes
     * @param {string} str - The string to escape
     * @returns {string} - Escaped string safe for evalScript
     */
  function escapeForEvalScript(str) {
    if (!str) {return '';}
    return String(str)
      .replace(/\\/g, '\\\\')  // Escape backslashes first
      .replace(/"/g, '\\"')     // Escape double quotes
      .replace(/'/g, '\\\'')     // Escape single quotes
      .replace(/\n/g, '\\n')    // Escape newlines
      .replace(/\r/g, '\\r');   // Escape carriage returns
  }



  // Initialize CSInterface

  const csInterface = new CSInterface();



  // Current state

  let currentClip = null;

  let allProjectClips = [];

  let currentClipIndex = -1;



  // UI Elements

  const elements = {

    clipName: document.getElementById('clipName'),

    clipPath: document.getElementById('clipPath'),



    // Form fields

    id: document.getElementById('id'),

    location: document.getElementById('location'),

    subject: document.getElementById('subject'),

    action: document.getElementById('action'),

    shotType: document.getElementById('shotType'),

    metadata: document.getElementById('metadata'),

    actionGroup: document.getElementById('actionGroup'),



    // Generated name preview

    generatedName: document.getElementById('generatedName'),



    // Buttons

    refreshBtn: document.getElementById('refreshBtn'),

    prevBtn: document.getElementById('prevBtn'),

    nextBtn: document.getElementById('nextBtn'),

    openSourceBtn: document.getElementById('openSourceBtn'),

    applyBtn: document.getElementById('applyBtn'),



    // Status

    statusMsg: document.getElementById('statusMsg')

  };



  /**

     * Initialize the panel

     */

  function init() {

    console.log('EAV Ingest Assistant initializing...');



    // Set up event listeners

    setupEventListeners();



    // Load initial selection

    loadSelectedClip();



    console.log('Panel initialized');

  }



  /**

     * Set up all event listeners

     */

  function setupEventListeners() {

    // Refresh button

    elements.refreshBtn.addEventListener('click', function() {

      loadSelectedClip();

    });



    // Form field changes - update preview

    elements.location.addEventListener('input', updateGeneratedName);

    elements.subject.addEventListener('input', updateGeneratedName);

    elements.action.addEventListener('input', updateGeneratedName);

    elements.shotType.addEventListener('change', updateGeneratedName);



    // Navigation buttons

    elements.prevBtn.addEventListener('click', navigateToPrevious);

    elements.nextBtn.addEventListener('click', navigateToNext);



    // Open in Source Monitor

    elements.openSourceBtn.addEventListener('click', openInSourceMonitor);



    // Apply button

    elements.applyBtn.addEventListener('click', applyMetadata);



    // Listen for Premiere Pro selection changes

    // Note: CEP doesn't have a direct selection change event,

    // but we can set up a periodic check or manual refresh

    setInterval(checkSelectionChange, 2000);

  }



  /**

     * Load currently selected clip from Premiere Pro

     */

  function loadSelectedClip() {

    showStatus('Loading selection...', 'info');



    csInterface.evalScript('EAVIngest.getSelectedClips()', function(result) {

      try {

        const data = JSON.parse(result);



        if (data.error) {

          showStatus(data.error, 'error');

          clearForm();

          return;

        }



        if (data.clips && data.clips.length > 0) {

          // Load the first selected clip

          currentClip = data.clips[0];

          loadClipIntoForm(currentClip);

          loadAllProjectClips();

          showStatus('Clip loaded: ' + currentClip.name, 'success');

        } else {

          showStatus('No clips selected', 'error');

          clearForm();

        }

      } catch (e) {

        console.error('Error parsing result:', e);

        showStatus('Error loading clip', 'error');

      }

    });

  }



  /**

     * Load clip data into form

     */

  function loadClipIntoForm(clip) {

    // Update header

    elements.clipName.textContent = clip.name;

    elements.clipPath.textContent = clip.treePath || '';



    // Parse ID from filename

    const parsedId = parseIdFromFilename(clip.name);

    elements.id.value = parsedId;



    // Load existing metadata from PP fields

    // Parse structured components from current name or tape name

    const components = parseStructuredComponents(clip.name);



    elements.location.value = components.location || '';

    elements.subject.value = components.subject || '';

    elements.action.value = components.action || '';

    elements.shotType.value = components.shotType || '';



    // Load Description field as metadata tags

    if (clip.description) {

      elements.metadata.value = clip.description;

    } else {

      elements.metadata.value = '';

    }



    // Show/hide action field based on type

    const isVideo = clip.mediaPath &&

                     (clip.mediaPath.toLowerCase().endsWith('.mp4') ||

                      clip.mediaPath.toLowerCase().endsWith('.mov') ||

                      clip.mediaPath.toLowerCase().endsWith('.mxf'));



    elements.actionGroup.style.display = isVideo ? 'flex' : 'none';



    // Update generated name preview

    updateGeneratedName();



    // Enable buttons

    elements.openSourceBtn.disabled = false;

    elements.applyBtn.disabled = false;

  }



  /**

     * Parse 8-digit ID from filename

     */

  function parseIdFromFilename(filename) {

    const match = filename.match(/^(\d{8})/);

    return match ? match[1] : '';

  }



  /**

     * Parse structured components from name

     * Expected format: {id}-{location}-{subject}-{action}-{shotType}

     * or for images: {id}-{location}-{subject}-{shotType}

     */

  function parseStructuredComponents(name) {

    // Remove extension

    const nameWithoutExt = name.replace(/\.[^.]+$/, '');



    // Split by hyphen

    const parts = nameWithoutExt.split('-');



    if (parts.length < 2) {

      return {};

    }



    // Skip the ID (first part)

    const components = {};



    if (parts.length >= 4) {

      // Video format: id-location-subject-action-shotType

      components.location = parts[1] || '';

      components.subject = parts[2] || '';

      components.action = parts[3] || '';

      components.shotType = parts[4] || '';

    } else if (parts.length === 4) {

      // Image format: id-location-subject-shotType

      components.location = parts[1] || '';

      components.subject = parts[2] || '';

      components.shotType = parts[3] || '';

    }



    return components;

  }



  /**

     * Update the generated name preview

     */

  function updateGeneratedName() {

    const id = elements.id.value;

    const location = elements.location.value.trim();

    const subject = elements.subject.value.trim();

    const action = elements.action.value.trim();

    const shotType = elements.shotType.value;



    const parts = [];



    if (id) {parts.push(id);}

    if (location) {parts.push(location);}

    if (subject) {parts.push(subject);}



    // Include action only if visible (videos)

    if (elements.actionGroup.style.display !== 'none' && action) {

      parts.push(action);

    }



    if (shotType) {parts.push(shotType);}



    const generatedName = parts.length > 0 ? parts.join('-') : '-';

    elements.generatedName.textContent = generatedName;

  }



  /**

     * Clear the form

     */

  function clearForm() {

    currentClip = null;

    elements.clipName.textContent = 'No clip selected';

    elements.clipPath.textContent = '';

    elements.id.value = '';

    elements.location.value = '';

    elements.subject.value = '';

    elements.action.value = '';

    elements.shotType.value = '';

    elements.metadata.value = '';

    elements.generatedName.textContent = '-';

    elements.openSourceBtn.disabled = true;

    elements.applyBtn.disabled = true;

  }



  /**

     * Load all project clips for navigation

     */

  function loadAllProjectClips() {

    csInterface.evalScript('EAVIngest.getAllProjectClips()', function(result) {

      try {

        const data = JSON.parse(result);

        if (data.clips) {

          allProjectClips = data.clips;



          // Find current clip index

          if (currentClip) {

            currentClipIndex = allProjectClips.findIndex(function(clip) {

              return clip.nodeId === currentClip.nodeId;

            });

          }



          updateNavigationButtons();

        }

      } catch (e) {

        console.error('Error loading project clips:', e);

      }

    });

  }



  /**

     * Update navigation button states

     */

  function updateNavigationButtons() {

    elements.prevBtn.disabled = currentClipIndex <= 0;

    elements.nextBtn.disabled = currentClipIndex >= allProjectClips.length - 1 || allProjectClips.length === 0;

  }



  /**

     * Navigate to previous clip

     */

  function navigateToPrevious() {

    if (currentClipIndex > 0) {

      const prevClip = allProjectClips[currentClipIndex - 1];

      selectAndLoadClip(prevClip.nodeId);

    }

  }



  /**

     * Navigate to next clip

     */

  function navigateToNext() {

    if (currentClipIndex < allProjectClips.length - 1) {

      const nextClip = allProjectClips[currentClipIndex + 1];

      selectAndLoadClip(nextClip.nodeId);

    }

  }



  /**

     * Select and load a specific clip

     */

  function selectAndLoadClip(nodeId) {

    // SECURITY: Escape nodeId to prevent code injection
    const escapedNodeId = escapeForEvalScript(nodeId);
    csInterface.evalScript('EAVIngest.selectClip("' + escapedNodeId + '")', function(result) {

      try {

        const data = JSON.parse(result);

        if (data.success) {

          // Wait a bit for PP to update, then load

          setTimeout(loadSelectedClip, 100);

        }

      } catch (e) {

        console.error('Error selecting clip:', e);

      }

    });

  }



  /**

     * Open current clip in Source Monitor

     */

  function openInSourceMonitor() {

    if (!currentClip) {return;}

    // SECURITY: Escape nodeId to prevent code injection
    const escapedNodeId = escapeForEvalScript(currentClip.nodeId);
    csInterface.evalScript('EAVIngest.openInSourceMonitor("' + escapedNodeId + '")', function(result) {

      try {

        const data = JSON.parse(result);

        if (data.success) {

          showStatus('Opened in Source Monitor', 'success');

        } else {

          showStatus('Error: ' + (data.error || 'Unknown error'), 'error');

        }

      } catch (e) {

        console.error('Error opening in source monitor:', e);

        showStatus('Error opening clip', 'error');

      }

    });

  }



  /**

     * Apply metadata to Premiere Pro

     */

  function applyMetadata() {

    if (!currentClip) {

      showStatus('No clip selected', 'error');

      return;

    }



    // Build the generated name

    const generatedName = elements.generatedName.textContent;

    if (generatedName === '-') {

      showStatus('Please fill in at least one field', 'error');

      return;

    }



    // Prepare metadata object

    const metadata = {

      name: generatedName,

      tapeName: currentClip.name, // Preserve original filename in Tape Name

      description: elements.metadata.value.trim(),

      shot: elements.shotType.value

    };



    showStatus('Updating Premiere Pro...', 'info');



    // Call ExtendScript to update PP

    const metadataJson = JSON.stringify(metadata).replace(/"/g, '\\"');

    const script = 'EAVIngest.updateClipMetadata("' + currentClip.nodeId + '", JSON.parse("' + metadataJson + '"))';



    csInterface.evalScript(script, function(result) {

      try {

        const data = JSON.parse(result);

        if (data.success) {

          showStatus(' Updated: ' + data.updatedName, 'success');



          // Update current clip name

          currentClip.name = data.updatedName;

          elements.clipName.textContent = data.updatedName;

        } else {

          showStatus('Error: ' + (data.error || 'Unknown error'), 'error');

        }

      } catch (e) {

        console.error('Error applying metadata:', e);

        showStatus('Error updating Premiere Pro', 'error');

      }

    });

  }



  /**

     * Check if selection has changed (polling)

     */

  let lastClipNodeId = null;

  function checkSelectionChange() {

    csInterface.evalScript('EAVIngest.getSelectedClips()', function(result) {

      try {

        const data = JSON.parse(result);

        if (data.clips && data.clips.length > 0) {

          const newNodeId = data.clips[0].nodeId;

          if (newNodeId !== lastClipNodeId) {

            lastClipNodeId = newNodeId;

            loadSelectedClip();

          }

        }

      } catch (e) {

        // Ignore errors during polling

      }

    });

  }



  /**

     * Show status message

     */

  function showStatus(message, type) {

    elements.statusMsg.textContent = message;

    elements.statusMsg.className = 'status-msg ' + type;



    // Auto-hide after 3 seconds

    if (type === 'success' || type === 'info') {

      setTimeout(function() {

        elements.statusMsg.style.display = 'none';

      }, 3000);

    }

  }



  // Initialize when DOM is ready

  if (document.readyState === 'loading') {

    document.addEventListener('DOMContentLoaded', init);

  } else {

    init();

  }



})();
</file>

<file path="index-old.html">
<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>EAV Ingest Assistant</title>

    <link rel="stylesheet" href="css/style.css">

</head>

<body>

    <div id="app" class="panel-container">

        <!-- Header with clip info -->

        <div class="header">

            <div class="clip-info">

                <span id="clipName" class="clip-name">No clip selected</span>

                <span id="clipPath" class="clip-path"></span>

            </div>

            <button id="refreshBtn" class="icon-btn" title="Refresh from selection">

                <svg width="16" height="16" viewBox="0 0 16 16">

                    <path fill="currentColor" d="M13.65 2.35C12.2 0.9 10.21 0 8 0 3.58 0 0 3.58 0 8s3.58 8 8 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L9 7h7V0l-2.35 2.35z"/>

                </svg>

            </button>

        </div>



        <!-- Form Fields (horizontal strip layout) -->

        <div class="form-strip">

            <!-- ID Field (read-only, extracted from filename) -->

            <div class="form-group compact">

                <label for="id">ID</label>

                <input type="text" id="id" readonly class="readonly-field" placeholder="Auto">

            </div>



            <!-- Location -->

            <div class="form-group">

                <label for="location">Location</label>

                <input type="text" id="location" placeholder="e.g. kitchen" list="locationList">

                <datalist id="locationList">

                    <option value="kitchen">

                    <option value="bathroom">

                    <option value="bedroom">

                    <option value="living-room">

                    <option value="exterior">

                </datalist>

            </div>



            <!-- Subject -->

            <div class="form-group">

                <label for="subject">Subject</label>

                <input type="text" id="subject" placeholder="e.g. oven" list="subjectList">

                <datalist id="subjectList">

                    <option value="sink">

                    <option value="oven">

                    <option value="window">

                    <option value="door">

                    <option value="countertop">

                </datalist>

            </div>



            <!-- Action (videos only) -->

            <div class="form-group" id="actionGroup">

                <label for="action">Action</label>

                <input type="text" id="action" placeholder="e.g. cleaning" list="actionList">

                <datalist id="actionList">

                    <option value="cleaning">

                    <option value="installing">

                    <option value="repairing">

                    <option value="painting">

                    <option value="demolishing">

                </datalist>

            </div>



            <!-- Shot Type -->

            <div class="form-group">

                <label for="shotType">Shot Type</label>

                <select id="shotType">

                    <option value="">--</option>

                    <option value="WS">WS (Wide Shot)</option>

                    <option value="MID">MID (Medium Shot)</option>

                    <option value="CU">CU (Close Up)</option>

                    <option value="UNDER">UNDER (Underslung)</option>

                    <option value="FP">FP (First Person)</option>

                    <option value="TRACK">TRACK (Tracking Shot)</option>

                    <option value="ESTAB">ESTAB (Establishing)</option>

                </select>

            </div>

        </div>



        <!-- Generated Name Preview -->

        <div class="name-preview">

            <label>Generated Name:</label>

            <div id="generatedName" class="generated-name-text">-</div>

        </div>



        <!-- Metadata Tags -->

        <div class="metadata-section">

            <label for="metadata">Metadata Tags (comma-separated):</label>

            <input type="text" id="metadata" placeholder="e.g. before, wide-angle, natural-light">

        </div>



        <!-- Action Bar -->

        <div class="action-bar">

            <div class="nav-buttons">

                <button id="prevBtn" class="nav-btn"> Previous</button>

                <button id="nextBtn" class="nav-btn">Next </button>

            </div>



            <div class="action-buttons">

                <button id="openSourceBtn" class="secondary-btn">Open in Source Monitor</button>

                <button id="applyBtn" class="primary-btn">Apply to Premiere</button>

            </div>

        </div>



        <!-- Status Messages -->

        <div id="statusMsg" class="status-msg"></div>



        <!-- Phase 2: AI Analysis (hidden for now) -->

        <div id="aiSection" class="ai-section" style="display: none;">

            <button id="analyzeBtn" class="secondary-btn"> AI Analyze</button>

            <div id="aiStatus" class="ai-status"></div>

        </div>

    </div>



    <!-- Load CEP Interface Library -->

    <script type="text/javascript" src="js/CSInterface.js"></script>

    <script type="text/javascript" src="js/main.js"></script>

</body>

</html>
</file>

<file path="js/metadata-panel.js">
/**
 * EAV Ingest Assistant - Metadata Panel
 * Component: Metadata Form with save functionality + Debug Panel
 */

(function() {
  'use strict';

  // ========================================
  // GLOBAL STATE
  // ========================================

  let currentClip = null;
  const navigationContext = {
    clipIndex: -1,
    totalClips: 0,
    filteredClips: []
  };

  // Initialize CSInterface
  let csInterface;
  try {
    csInterface = new CSInterface();
    addDebug(' CSInterface initialized: ' + csInterface.getHostEnvironment().appVersion);
  } catch (e) {
    alert('Error: CSInterface not available. ' + e.message);
    return;
  }

  // ========================================
  // DEBUG PANEL
  // ========================================

  function addDebug(message, isError) {
    const debugContent = document.getElementById('debugContent');
    if (!debugContent) {return;}

    const line = document.createElement('div');
    line.className = 'debug-line' + (isError ? ' error' : '');

    const time = document.createElement('span');
    time.className = 'debug-time';
    time.textContent = new Date().toTimeString().substr(0, 8);

    const msg = document.createElement('span');
    msg.className = 'debug-message';
    msg.textContent = message;

    line.appendChild(time);
    line.appendChild(msg);
    debugContent.appendChild(line);

    // Auto-scroll to bottom
    debugContent.scrollTop = debugContent.scrollHeight;

    // Keep max 200 lines
    while (debugContent.children.length > 200) {
      debugContent.removeChild(debugContent.firstChild);
    }
  }

  function clearDebug() {
    const debugContent = document.getElementById('debugContent');
    if (debugContent) {
      debugContent.innerHTML = '';
      addDebug('Debug log cleared');
    }
  }

  // ========================================
  // SECURITY: String escaping for evalScript
  // ========================================

  /**
     * Escape a string for safe use in evalScript string concatenation
     * Prevents code injection by escaping quotes and backslashes
     * @param {string} str - The string to escape
     * @returns {string} - Escaped string safe for evalScript
     */
  function escapeForEvalScript(str) {
    if (!str) {return '';}
    return String(str)
      .replace(/\\/g, '\\\\')  // Escape backslashes first
      .replace(/"/g, '\\"')     // Escape double quotes
      .replace(/'/g, '\\\'')     // Escape single quotes
      .replace(/\n/g, '\\n')    // Escape newlines
      .replace(/\r/g, '\\r');   // Escape carriage returns
  }

  // ========================================
  // COMPONENT: METADATA FORM
  // ========================================

  const MetadataForm = {
    elements: {
      formClipName: null,
      identifier: null,
      description: null,
      good: null,
      location: null,
      subject: null,
      action: null,
      shotType: null,
      actionGroup: null,
      generatedName: null,
      prevBtn: null,
      applyBtn: null,
      nextBtn: null,
      status: null
    },

    init: function() {
      addDebug('[MetadataForm] Starting init...');

      // Get DOM elements
      this.elements = {
        formClipName: document.getElementById('formClipName'),
        identifier: document.getElementById('metadataTapeName'),
        description: document.getElementById('metadataDescription'),
        good: document.getElementById('metadataGood'),
        location: document.getElementById('metadataLocation'),
        subject: document.getElementById('metadataSubject'),
        action: document.getElementById('metadataAction'),
        shotType: document.getElementById('metadataShotType'),
        actionGroup: document.getElementById('actionGroup'),
        generatedName: document.getElementById('generatedName'),
        prevBtn: document.getElementById('prevBtn'),
        applyBtn: document.getElementById('applyBtn'),
        nextBtn: document.getElementById('nextBtn'),
        status: document.getElementById('formStatus')
      };
      addDebug('[MetadataForm]  DOM elements retrieved');

      // Set up event listeners
      this.setupEventListeners();
      addDebug('[MetadataForm]  Event listeners set up');
    },

    setupEventListeners: function() {
      const self = this;

      // Listen for clip selection from Navigation Panel (CEP event)
      csInterface.addEventListener('com.elevana.clip-selected', function(event) {
        addDebug('[MetadataForm] Received CEP clip-selected event');
        try {
          // Parse event data (might be string or already parsed object)
          const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

          // Handle both old format (just clip) and new format (clip + navigation context)
          let clip, clipIndex, totalClips, filteredClips;
          if (data.clip) {
            // New format: {clip, clipIndex, totalClips, filteredClips}
            clip = data.clip;
            clipIndex = data.clipIndex;
            totalClips = data.totalClips;
            filteredClips = data.filteredClips;
            addDebug('[MetadataForm] Navigation context: ' + clipIndex + '/' + totalClips);
          } else {
            // Old format: just clip object (backward compatibility)
            clip = data;
            clipIndex = -1;
            totalClips = 0;
            filteredClips = [];
          }

          // Store navigation context globally
          navigationContext.clipIndex = clipIndex;
          navigationContext.totalClips = totalClips;
          navigationContext.filteredClips = filteredClips;

          addDebug('[MetadataForm] Parsed clip: ' + clip.name);
          self.loadClipIntoForm(clip);
          self.updateNavigationButtons();
        } catch (e) {
          addDebug('[MetadataForm]  Failed to parse event data: ' + e.message, true);
          addDebug('[MetadataForm] Event data type: ' + typeof event.data, true);
          addDebug('[MetadataForm] Event data: ' + event.data, true);
        }
      });

      // Form field changes - update preview
      this.elements.location.addEventListener('input', function() { self.updateGeneratedName(); });
      this.elements.subject.addEventListener('input', function() { self.updateGeneratedName(); });
      this.elements.action.addEventListener('input', function() { self.updateGeneratedName(); });

      // Setup searchable dropdown for Shot Type
      this.setupSearchableDropdown();

      // Apply button
      this.elements.applyBtn.addEventListener('click', function() {
        self.applyMetadata();
      });

      // Previous button
      this.elements.prevBtn.addEventListener('click', function() {
        self.navigatePrevious();
      });

      // Next button
      this.elements.nextBtn.addEventListener('click', function() {
        self.navigateNext();
      });
    },

    setupSearchableDropdown: function() {
      const self = this;
      const input = this.elements.shotType;
      const dropdown = document.getElementById('shotTypeDropdown');

      // Safety check - ensure elements exist
      if (!input || !dropdown) {
        addDebug('[MetadataForm]  Searchable dropdown elements not found', true);
        return;
      }

      const options = dropdown.querySelectorAll('.dropdown-option');
      const validValues = [];
      let previousValue = '';
      let highlightedIndex = -1;

      addDebug('[MetadataForm]  Setting up searchable dropdown');

      // Collect valid values
      options.forEach(function(option) {
        validValues.push(option.getAttribute('data-value'));
      });

      // Show dropdown on focus
      input.addEventListener('focus', function() {
        previousValue = input.value;
        dropdown.style.display = 'block';
        filterOptions(input.value);
      });

      // Filter options as user types
      input.addEventListener('input', function() {
        filterOptions(input.value);
        self.updateGeneratedName(); // Update preview
      });

      // Handle keyboard navigation
      input.addEventListener('keydown', function(e) {
        const visibleOptions = Array.from(options).filter(function(opt) {
          return opt.style.display !== 'none';
        });

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          highlightedIndex = Math.min(highlightedIndex + 1, visibleOptions.length - 1);
          updateHighlight(visibleOptions);
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          highlightedIndex = Math.max(highlightedIndex - 1, 0);
          updateHighlight(visibleOptions);
        } else if (e.key === 'Enter') {
          e.preventDefault();
          if (highlightedIndex >= 0 && visibleOptions[highlightedIndex]) {
            selectOption(visibleOptions[highlightedIndex]);
          } else if (visibleOptions.length === 1) {
            selectOption(visibleOptions[0]);
          }
        } else if (e.key === 'Escape') {
          e.preventDefault();
          input.value = previousValue;
          dropdown.style.display = 'none';
          highlightedIndex = -1;
        }
      });

      // Handle option click
      options.forEach(function(option) {
        option.addEventListener('click', function() {
          selectOption(option);
        });
      });

      // Validate on blur
      input.addEventListener('blur', function(e) {
        // Delay to allow option click to register
        setTimeout(function() {
          const value = input.value.toUpperCase().trim();

          if (value && validValues.indexOf(value) === -1) {
            // Invalid value - revert to previous
            addDebug('[MetadataForm]  Invalid shot type: "' + value + '" - reverting', true);
            input.value = previousValue;
            self.updateGeneratedName();
          }

          dropdown.style.display = 'none';
          highlightedIndex = -1;
        }, 150);
      });

      // Filter options helper
      function filterOptions(searchTerm) {
        const search = searchTerm.toUpperCase().trim();
        let visibleCount = 0;
        highlightedIndex = -1;

        options.forEach(function(option) {
          const value = option.getAttribute('data-value');
          const text = option.textContent;

          if (!search || value.indexOf(search) === 0 || text.toUpperCase().indexOf(search) >= 0) {
            option.style.display = 'block';
            option.classList.remove('highlighted');
            visibleCount++;
          } else {
            option.style.display = 'none';
            option.classList.remove('highlighted');
          }
        });

        // Show "No matches" if no options visible
        if (visibleCount === 0 && search) {
          // Could add a "no matches" message here
        }
      }

      // Update highlight helper
      function updateHighlight(visibleOptions) {
        options.forEach(function(opt) {
          opt.classList.remove('highlighted');
        });

        if (highlightedIndex >= 0 && visibleOptions[highlightedIndex]) {
          visibleOptions[highlightedIndex].classList.add('highlighted');
          visibleOptions[highlightedIndex].scrollIntoView({ block: 'nearest' });
        }
      }

      // Select option helper
      function selectOption(option) {
        const value = option.getAttribute('data-value');
        input.value = value;
        previousValue = value;
        dropdown.style.display = 'none';
        highlightedIndex = -1;
        addDebug('[MetadataForm]  Shot Type selected: ' + value);
        self.updateGeneratedName();
      }
    },

    loadClipIntoForm: function(clip) {
      addDebug('[MetadataForm] Loading clip: ' + (clip ? clip.name : 'null'));

      // Validate clip object
      if (!clip) {
        addDebug('[MetadataForm]  Clip is null', true);
        return;
      }

      if (!clip.nodeId) {
        addDebug('[MetadataForm]  Clip nodeId missing', true);
        return;
      }

      currentClip = clip;

      // DEBUG: Show entire clip object structure
      addDebug('[MetadataForm] === CLIP OBJECT DEBUG ===');
      addDebug('[MetadataForm] clip.name: "' + (clip.name || 'EMPTY') + '"');
      addDebug('[MetadataForm] clip.identifier: "' + (clip.identifier || 'EMPTY') + '"');
      addDebug('[MetadataForm] clip.description: "' + (clip.description || 'EMPTY') + '"');
      addDebug('[MetadataForm] clip.good: "' + (clip.good || 'EMPTY') + '"');
      addDebug('[MetadataForm] clip.shot: "' + (clip.shot || 'EMPTY') + '"');
      addDebug('[MetadataForm] clip.location: "' + (clip.location || 'EMPTY') + '"');
      addDebug('[MetadataForm] clip.subject: "' + (clip.subject || 'EMPTY') + '"');
      addDebug('[MetadataForm] clip.action: "' + (clip.action || 'EMPTY') + '"');
      addDebug('[MetadataForm] === END DEBUG ===');

      // Update header
      this.elements.formClipName.textContent = clip.name;

      // Load Identifier from Dublin Core (or fall back to clip name)
      const identifierValue = clip.identifier || clip.name || '';
      this.elements.identifier.value = identifierValue;
      addDebug('[MetadataForm]  Identifier set to: "' + identifierValue + '"');

      // Load Description field
      const descriptionValue = clip.description || '';
      this.elements.description.value = descriptionValue;
      addDebug('[MetadataForm]  Description set to: "' + descriptionValue + '"');

      // Load Good checkbox (check if 'true' string or true boolean)
      const goodValue = (clip.good === 'true' || clip.good === true);
      this.elements.good.checked = goodValue;
      addDebug('[MetadataForm]  Good checkbox set to: ' + goodValue);

      // Load Location, Subject, Action, Shot Type from XMP (with fallback to filename parsing)
      if (clip.location || clip.subject || clip.action || clip.shot) {
        // XMP data exists - use it directly
        this.elements.location.value = clip.location || '';
        this.elements.subject.value = clip.subject || '';
        this.elements.action.value = clip.action || '';
        this.elements.shotType.value = clip.shot || '';
        addDebug('[MetadataForm]  Loaded from XMP metadata');
      } else {
        // Fallback: Parse from filename for clips without XMP metadata
        const components = this.parseStructuredComponents(clip.name);
        this.elements.location.value = components.location || '';
        this.elements.subject.value = components.subject || '';
        this.elements.action.value = components.action || '';
        this.elements.shotType.value = components.shotType || '';
        addDebug('[MetadataForm]  Parsed from filename (no XMP data)');
      }

      // Show/hide action field based on type (heuristic: video files have action)
      const isVideo = /\.(mov|mp4|mxf|avi)$/i.test(clip.mediaPath);
      this.elements.actionGroup.style.display = isVideo ? 'block' : 'none';

      // Update generated name preview
      this.updateGeneratedName();

      // Enable apply button
      this.elements.applyBtn.disabled = false;

      addDebug('[MetadataForm]  Clip loaded into form');
    },

    parseStructuredComponents: function(name) {
      // Remove extension
      const nameWithoutExt = name.replace(/\.[^.]+$/, '');

      // Split by hyphen
      const parts = nameWithoutExt.split('-');

      if (parts.length < 2) {
        return {};
      }

      const components = {};

      if (parts.length >= 5) {
        // Video format: id-location-subject-action-shotType
        components.location = parts[1] || '';
        components.subject = parts[2] || '';
        components.action = parts[3] || '';
        components.shotType = parts[4] || '';
      } else if (parts.length === 4) {
        // Image format: id-location-subject-shotType
        components.location = parts[1] || '';
        components.subject = parts[2] || '';
        components.shotType = parts[3] || '';
      }

      return components;
    },

    updateGeneratedName: function() {
      const location = this.elements.location.value.trim();
      const subject = this.elements.subject.value.trim();
      const action = this.elements.action.value.trim();
      const shotType = this.elements.shotType.value;

      const parts = [];

      if (location) {parts.push(location);}
      if (subject) {parts.push(subject);}

      // Include action only if visible (videos)
      const actionVisible = this.elements.actionGroup.style.display !== 'none';
      if (actionVisible && action) {
        parts.push(action);
      }

      if (shotType) {parts.push(shotType);}

      const generatedName = parts.length > 0 ? parts.join('-') : '-';
      this.elements.generatedName.textContent = generatedName;
    },

    applyMetadata: function() {
      const self = this;
      addDebug('[MetadataForm] Applying metadata...');

      if (!currentClip) {
        addDebug('[MetadataForm]  No clip selected', true);
        this.showStatus('No clip selected', 'error');
        return;
      }

      // Build the generated name
      const generatedName = this.elements.generatedName.textContent;

      if (generatedName === '-') {
        addDebug('[MetadataForm]  No fields filled in', true);
        this.showStatus('Please fill in at least one field', 'error');
        return;
      }

      // Prepare metadata object
      const metadata = {
        name: generatedName,
        identifier: this.elements.identifier.value || currentClip.name,
        description: this.elements.description.value.trim(),
        shot: this.elements.shotType.value,
        good: this.elements.good.checked ? 'true' : 'false',
        location: this.elements.location.value.trim(),
        subject: this.elements.subject.value.trim(),
        action: this.elements.action.value.trim()
      };

      addDebug('[MetadataForm] Metadata: ' + JSON.stringify(metadata));
      this.showStatus('Updating Premiere Pro...', 'info');

      // Call ExtendScript to update PP
      // SECURITY: Escape nodeId to prevent code injection
      const metadataJson = JSON.stringify(metadata);
      const escapedNodeId = escapeForEvalScript(currentClip.nodeId);
      const escapedMetadataJson = metadataJson.replace(/'/g, '\\\'');
      const script = 'EAVIngest.updateClipMetadata("' + escapedNodeId + '", JSON.parse(\'' + escapedMetadataJson + '\'))';

      csInterface.evalScript(script, function(result) {
        try {
          const data = JSON.parse(result);

          if (data.success) {
            addDebug('[MetadataForm]  Updated: ' + data.updatedName);

            // Display ExtendScript debug info
            if (data.debug && data.debug.length > 0) {
              addDebug('[ExtendScript Debug] ===== START =====');
              for (let i = 0; i < data.debug.length; i++) {
                addDebug('[ExtendScript] ' + data.debug[i]);
              }
              addDebug('[ExtendScript Debug] ===== END =====');
            }

            self.showStatus(' Updated: ' + data.updatedName, 'success');

            // Update current clip name in state
            currentClip.name = data.updatedName;

            // Emit CEP event to notify Navigation Panel
            try {
              const metadataEvent = new CSEvent('com.elevana.metadata-applied', 'APPLICATION');
              metadataEvent.data = JSON.stringify({ nodeId: currentClip.nodeId, name: data.updatedName });
              csInterface.dispatchEvent(metadataEvent);
              addDebug('[MetadataForm]  CEP metadata-applied event dispatched');
            } catch (e) {
              addDebug('[MetadataForm]  Failed to dispatch metadata event: ' + e.message, true);
            }
          } else {
            addDebug('[MetadataForm]  Error: ' + data.error, true);
            self.showStatus('Error: ' + data.error, 'error');
          }
        } catch (e) {
          addDebug('[MetadataForm]  Parse error: ' + e.message, true);
          self.showStatus('Failed to update metadata', 'error');
        }
      });
    },

    showStatus: function(message, type) {
      this.elements.status.textContent = message;
      this.elements.status.className = 'form-status ' + type;

      // Auto-clear success/info messages
      if (type === 'success' || type === 'info') {
        setTimeout(function() {
          this.elements.status.textContent = '';
          this.elements.status.className = 'form-status';
        }.bind(this), 3000);
      }
    },

    updateNavigationButtons: function() {
      const clipIndex = navigationContext.clipIndex;
      const totalClips = navigationContext.totalClips;

      addDebug('[MetadataForm] Updating navigation buttons: ' + clipIndex + '/' + totalClips);

      // Enable/disable Previous button
      this.elements.prevBtn.disabled = (clipIndex <= 0);

      // Enable/disable Next button
      this.elements.nextBtn.disabled = (clipIndex >= totalClips - 1);
    },

    navigatePrevious: function() {
      const clipIndex = navigationContext.clipIndex;
      const filteredClips = navigationContext.filteredClips;

      if (clipIndex > 0 && filteredClips.length > 0) {
        const previousClip = filteredClips[clipIndex - 1];
        addDebug('[MetadataForm]  Navigating to previous clip: ' + previousClip.name);

        // Dispatch CEP event to select this clip in Navigation Panel
        try {
          const event = new CSEvent('com.elevana.clip-selected', 'APPLICATION');
          event.data = JSON.stringify({
            clip: previousClip,
            clipIndex: clipIndex - 1,
            totalClips: filteredClips.length,
            filteredClips: filteredClips
          });
          csInterface.dispatchEvent(event);
        } catch (e) {
          addDebug('[MetadataForm]  Failed to navigate previous: ' + e.message, true);
        }
      }
    },

    navigateNext: function() {
      const clipIndex = navigationContext.clipIndex;
      const filteredClips = navigationContext.filteredClips;

      if (clipIndex < filteredClips.length - 1 && filteredClips.length > 0) {
        const nextClip = filteredClips[clipIndex + 1];
        addDebug('[MetadataForm]  Navigating to next clip: ' + nextClip.name);

        // Dispatch CEP event to select this clip in Navigation Panel
        try {
          const event = new CSEvent('com.elevana.clip-selected', 'APPLICATION');
          event.data = JSON.stringify({
            clip: nextClip,
            clipIndex: clipIndex + 1,
            totalClips: filteredClips.length,
            filteredClips: filteredClips
          });
          csInterface.dispatchEvent(event);
        } catch (e) {
          addDebug('[MetadataForm]  Failed to navigate next: ' + e.message, true);
        }
      }
    }
  };

  // ========================================
  // INITIALIZATION
  // ========================================

  function init() {
    addDebug('=== Metadata Panel Initializing ===');

    // Initialize Debug Panel clear button
    const clearDebugBtn = document.getElementById('clearDebug');
    if (clearDebugBtn) {
      clearDebugBtn.addEventListener('click', clearDebug);
      addDebug(' Debug panel ready');
    }

    // Initialize MetadataForm
    MetadataForm.init();
    addDebug(' MetadataForm initialized');

    addDebug('=== Metadata Panel Ready ===');
    addDebug('Waiting for clip selection from Navigation Panel...');
  }

  // Start when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

})();
</file>

<file path="index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EAV Ingest Assistant - Self-Contained Panel</title>
    <link rel="stylesheet" href="css/panel-layout.css">
</head>
<body>
    <!-- Three-Panel Grid Layout -->
    <div id="app" class="panel-container">

        <!-- LEFT PANEL: Clip Browser (25%) -->
        <aside class="clip-browser" id="clipBrowser">
            <!-- Search Bar -->
            <div class="search-bar">
                <input
                    type="text"
                    id="clipSearch"
                    placeholder="Search clips..."
                    aria-label="Search clips"
                />
                <button id="clearSearch" class="icon-btn" aria-label="Clear search"></button>
            </div>

            <!-- Filters -->
            <div class="filters">
                <label class="filter-checkbox">
                    <input type="checkbox" id="filterVideo" checked>
                    Video
                </label>
                <label class="filter-checkbox">
                    <input type="checkbox" id="filterImage" checked>
                    Image
                </label>
                <label class="filter-checkbox">
                    <input type="checkbox" id="filterHasMeta">
                    Tagged
                </label>
            </div>

            <!-- Clip List -->
            <div class="clip-list" id="clipList" role="list">
                <!-- Dynamically generated clip items will go here -->
                <div class="clip-list-empty">
                    <p>No project loaded</p>
                    <p class="hint">Open a Premiere Pro project</p>
                </div>
            </div>

            <!-- Footer with count -->
            <div class="clip-browser-footer">
                <span id="clipCount">0 clips</span>
                <button id="refreshClips" class="icon-btn" title="Refresh clips">
                    <svg width="14" height="14" viewBox="0 0 16 16">
                        <path fill="currentColor" d="M13.65 2.35C12.2 0.9 10.21 0 8 0 3.58 0 0 3.58 0 8s3.58 8 8 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L9 7h7V0l-2.35 2.35z"/>
                    </svg>
                </button>
            </div>
        </aside>

        <!-- RIGHT PANEL: Thumbnail Viewer (top) + Metadata Form (bottom) -->
        <div class="right-panel-container">
            <!-- TOP: Thumbnail Viewer -->
            <main class="thumbnail-viewer" id="thumbnailViewer">
            <!-- Thumbnail Display -->
            <div class="thumbnail-container">
                <div class="thumbnail-placeholder" id="thumbnailPlaceholder">
                    <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                        <circle cx="8.5" cy="8.5" r="1.5"/>
                        <polyline points="21 15 16 10 5 21"/>
                    </svg>
                    <p>No clip selected</p>
                </div>
                <img
                    id="thumbnailImage"
                    class="thumbnail-image"
                    style="display: none;"
                    alt="Clip thumbnail"
                />
            </div>

            <!-- Clip Info Bar -->
            <div class="thumbnail-info">
                <div class="thumbnail-clip-name" id="thumbnailClipName">-</div>
                <div class="thumbnail-clip-details" id="thumbnailClipDetails">-</div>
            </div>

            <!-- Action Buttons -->
            <div class="thumbnail-actions">
                <button id="openSourceBtn" class="btn-secondary" disabled>
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Open in Source Monitor
                </button>
            </div>

            <!-- Status Messages -->
            <div id="thumbnailStatus" class="thumbnail-status"></div>
            </main>

            <!-- BOTTOM: Metadata Form -->
            <aside class="metadata-form" id="metadataForm">
            <!-- Form Header -->
            <div class="form-header">
                <h3>Metadata</h3>
                <span id="formClipName" class="form-clip-name">No clip selected</span>
            </div>

            <!-- Form Fields -->
            <div class="form-content">
                <!-- ID Field (read-only) -->
                <div class="form-group">
                    <label for="id">ID</label>
                    <input
                        type="text"
                        id="id"
                        readonly
                        class="readonly-field"
                        placeholder="Auto"
                    />
                </div>

                <!-- Location -->
                <div class="form-group">
                    <label for="location">Location</label>
                    <input
                        type="text"
                        id="location"
                        placeholder="e.g. kitchen"
                        list="locationList"
                    />
                    <datalist id="locationList">
                        <option value="kitchen">
                        <option value="bathroom">
                        <option value="bedroom">
                        <option value="living-room">
                        <option value="exterior">
                    </datalist>
                </div>

                <!-- Subject -->
                <div class="form-group">
                    <label for="subject">Subject</label>
                    <input
                        type="text"
                        id="subject"
                        placeholder="e.g. oven"
                        list="subjectList"
                    />
                    <datalist id="subjectList">
                        <option value="sink">
                        <option value="oven">
                        <option value="window">
                        <option value="door">
                        <option value="countertop">
                    </datalist>
                </div>

                <!-- Action (videos only) -->
                <div class="form-group" id="actionGroup">
                    <label for="action">Action</label>
                    <input
                        type="text"
                        id="action"
                        placeholder="e.g. cleaning"
                        list="actionList"
                    />
                    <datalist id="actionList">
                        <option value="cleaning">
                        <option value="installing">
                        <option value="repairing">
                        <option value="painting">
                        <option value="demolishing">
                    </datalist>
                </div>

                <!-- Shot Type -->
                <div class="form-group">
                    <label for="shotType">Shot Type</label>
                    <select id="shotType">
                        <option value="">--</option>
                        <option value="WS">WS (Wide Shot)</option>
                        <option value="MID">MID (Medium Shot)</option>
                        <option value="CU">CU (Close Up)</option>
                        <option value="UNDER">UNDER (Underslung)</option>
                        <option value="FP">FP (First Person)</option>
                        <option value="TRACK">TRACK (Tracking Shot)</option>
                        <option value="ESTAB">ESTAB (Establishing)</option>
                    </select>
                </div>

                <!-- Metadata Tags -->
                <div class="form-group">
                    <label for="metadata">Metadata Tags</label>
                    <input
                        type="text"
                        id="metadata"
                        placeholder="e.g. before, wide-angle, natural-light"
                    />
                    <small>Comma-separated tags</small>
                </div>

                <!-- Generated Name Preview -->
                <div class="name-preview">
                    <label>Generated Name:</label>
                    <div id="generatedName" class="generated-name-text">-</div>
                </div>
            </div>

            <!-- Form Actions -->
            <div class="form-actions">
                <div class="nav-buttons">
                    <button id="prevBtn" class="btn-nav" disabled> Previous</button>
                    <button id="nextBtn" class="btn-nav" disabled>Next </button>
                </div>
                <button id="applyBtn" class="btn-primary" disabled>Apply to Premiere</button>
            </div>

            <!-- Status Messages -->
            <div id="formStatus" class="form-status"></div>
            </aside>
        </div>

    </div>

    <!-- Load CEP Interface Library -->
    <script type="text/javascript" src="js/CSInterface.js"></script>
    <script type="text/javascript" src="js/panel-main.js"></script>
</body>
</html>
</file>

<file path="js/navigation-panel.js">
/**
 * EAV Ingest Assistant - Navigation Panel
 * Component: ClipBrowser with auto-open in Source Monitor + Debug Panel
 */

(function() {
  'use strict';

  // ========================================
  // GLOBAL STATE
  // ========================================

  const PanelState = {
    allClips: [],              // All project clips
    currentClip: null,         // Currently selected clip
    currentClipIndex: -1,      // Index in allClips
    searchFilter: '',          // Search text
    filterVideo: true,         // Show videos
    filterImage: true,         // Show images
    filterHasMeta: false,      // Show only tagged clips
    sortBy: 'bin',             // Sort order: 'name', 'name-desc', 'bin'
    selectedClips: []          // Array of nodeIds for batch operations
  };

  // Initialize CSInterface
  let csInterface;
  try {
    csInterface = new CSInterface();
    addDebug(' CSInterface initialized: ' + csInterface.getHostEnvironment().appVersion);
  } catch (e) {
    alert('Error: CSInterface not available. ' + e.message);
    return;
  }

  // ========================================
  // DEBUG PANEL
  // ========================================

  function addDebug(message, isError) {
    const debugContent = document.getElementById('debugContent');
    if (!debugContent) {return;}

    const line = document.createElement('div');
    line.className = 'debug-line' + (isError ? ' error' : '');

    const time = document.createElement('span');
    time.className = 'debug-time';
    time.textContent = new Date().toTimeString().substr(0, 8);

    const msg = document.createElement('span');
    msg.className = 'debug-message';
    msg.textContent = message;

    line.appendChild(time);
    line.appendChild(msg);
    debugContent.appendChild(line);

    // Auto-scroll to bottom
    debugContent.scrollTop = debugContent.scrollHeight;

    // Keep max 200 lines
    while (debugContent.children.length > 200) {
      debugContent.removeChild(debugContent.firstChild);
    }
  }

  function clearDebug() {
    const debugContent = document.getElementById('debugContent');
    if (debugContent) {
      debugContent.innerHTML = '';
      addDebug('Debug log cleared');
    }
  }

  // HTML escaping utility (XSS prevention)
  function escapeHTML(str) {
    if (!str) {return '';}
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  // ========================================
  // SECURITY: String escaping for evalScript
  // ========================================

  /**
     * Escape a string for safe use in evalScript string concatenation
     * Prevents code injection by escaping quotes and backslashes
     * @param {string} str - The string to escape
     * @returns {string} - Escaped string safe for evalScript
     */
  function escapeForEvalScript(str) {
    if (!str) {return '';}
    return String(str)
      .replace(/\\/g, '\\\\')  // Escape backslashes first
      .replace(/"/g, '\\"')     // Escape double quotes
      .replace(/'/g, '\\\'')     // Escape single quotes
      .replace(/\n/g, '\\n')    // Escape newlines
      .replace(/\r/g, '\\r');   // Escape carriage returns
  }

  // ========================================
  // COMPONENT: CLIP BROWSER
  // ========================================

  const ClipBrowser = {
    elements: {
      searchInput: null,
      clearSearchBtn: null,
      filterVideo: null,
      filterImage: null,
      filterHasMeta: null,
      sortBy: null,
      clipList: null,
      clipCount: null,
      refreshBtn: null
    },

    init: function() {
      const self = this;
      addDebug('[ClipBrowser] Starting init...');

      // Get DOM elements
      this.elements = {
        searchInput: document.getElementById('clipSearch'),
        clearSearchBtn: document.getElementById('clearSearch'),
        filterVideo: document.getElementById('filterVideo'),
        filterImage: document.getElementById('filterImage'),
        filterHasMeta: document.getElementById('filterHasMeta'),
        sortBy: document.getElementById('sortBy'),
        clipList: document.getElementById('clipList'),
        clipCount: document.getElementById('clipCount'),
        refreshBtn: document.getElementById('refreshClips'),
        selectAll: document.getElementById('selectAll'),
        selectNone: document.getElementById('selectNone'),
        selectedCount: document.getElementById('selectedCount'),
        batchApply: document.getElementById('batchApply')
      };
      addDebug('[ClipBrowser]  DOM elements retrieved');

      // Set up event listeners
      this.setupEventListeners();
      addDebug('[ClipBrowser]  Event listeners set up');

      // Load all clips from project (with delay on first load to let XMP cache warm up)
      addDebug('[ClipBrowser] Waiting for XMP metadata to load...');
      setTimeout(function() {
        self.loadAllClips();
      }, 1500); // 1.5 second delay for Premiere to fully load XMP
    },

    setupEventListeners: function() {
      const self = this;

      // Search input
      this.elements.searchInput.addEventListener('input', function(e) {
        PanelState.searchFilter = e.target.value;
        self.render();
      });

      // Clear search
      this.elements.clearSearchBtn.addEventListener('click', function() {
        self.elements.searchInput.value = '';
        PanelState.searchFilter = '';
        self.render();
      });

      // Filters
      this.elements.filterVideo.addEventListener('change', function(e) {
        PanelState.filterVideo = e.target.checked;
        self.render();
      });

      this.elements.filterImage.addEventListener('change', function(e) {
        PanelState.filterImage = e.target.checked;
        self.render();
      });

      this.elements.filterHasMeta.addEventListener('change', function(e) {
        PanelState.filterHasMeta = e.target.checked;
        self.render();
      });

      // Sort dropdown
      this.elements.sortBy.addEventListener('change', function(e) {
        PanelState.sortBy = e.target.value;
        addDebug('[ClipBrowser] Sort changed to: ' + PanelState.sortBy);
        self.render();
      });

      // Refresh button
      this.elements.refreshBtn.addEventListener('click', function() {
        self.loadAllClips();
      });

      // Batch selection controls
      this.elements.selectAll.addEventListener('click', function() {
        self.selectAllClips();
      });

      this.elements.selectNone.addEventListener('click', function() {
        self.clearSelection();
      });

      this.elements.batchApply.addEventListener('click', function() {
        self.batchApplyToPremiere();
      });

      // Keyboard shortcut: Cmd+Shift+A for batch apply
      document.addEventListener('keydown', function(e) {
        if (e.metaKey && e.shiftKey && e.key === 'A') {
          e.preventDefault();
          if (PanelState.selectedClips.length > 0) {
            self.batchApplyToPremiere();
          }
        }
      });

      // Clip list click handling (event delegation)
      this.elements.clipList.addEventListener('click', function(e) {
        // Ignore clicks on bin headers
        if (e.target.closest('.bin-header')) {
          return;
        }

        // Handle checkbox clicks
        if (e.target.classList.contains('clip-checkbox')) {
          var clipItem = e.target.closest('.clip-item');
          if (clipItem) {
            var nodeId = clipItem.getAttribute('data-clip-id');
            self.toggleClipSelection(nodeId);
            e.stopPropagation(); // Don't trigger clip selection
          }
          return;
        }

        // Handle clip selection (clicking anywhere else on the clip item)
        var clipItem = e.target.closest('.clip-item');
        if (clipItem) {
          var nodeId = clipItem.getAttribute('data-clip-id');
          self.selectClip(nodeId);
        }
      });

      // Listen for metadata updates from Metadata Panel (CEP event)
      csInterface.addEventListener('com.elevana.metadata-applied', function(event) {
        addDebug('[ClipBrowser] Received metadata-applied event');
        try {
          // event.data might be string or already parsed object
          const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
          addDebug('[ClipBrowser] Metadata updated for: ' + data.name);
          // Refresh clip list to show updated name
          self.loadAllClips();
        } catch (e) {
          addDebug('[ClipBrowser]  Failed to parse metadata event: ' + e.message, true);
        }
      });

      // Listen for clip selection from Metadata Panel navigation (CEP event)
      csInterface.addEventListener('com.elevana.clip-selected', function(event) {
        addDebug('[ClipBrowser] Received clip-selected event (external navigation)');
        try {
          // Parse event data
          const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

          // Handle both old format (just clip) and new format (clip + navigation context)
          const clip = data.clip || data;

          if (clip && clip.nodeId) {
            addDebug('[ClipBrowser] Syncing to: ' + clip.name);
            // Use syncSelection() to update UI without triggering Source Monitor or new event
            self.syncSelection(clip.nodeId);
          } else {
            addDebug('[ClipBrowser]  Invalid clip data in event', true);
          }
        } catch (e) {
          addDebug('[ClipBrowser]  Failed to parse clip-selected event: ' + e.message, true);
        }
      });
    },

    loadAllClips: function() {
      const self = this;
      addDebug('[ClipBrowser] Loading clips from project...');

      if (!csInterface) {
        addDebug('[ClipBrowser]  csInterface not available!', true);
        self.showEmptyState('CSInterface not initialized');
        return;
      }

      // Test if ExtendScript is available
      csInterface.evalScript('typeof EAVIngest', function(testResult) {
        addDebug('[ClipBrowser] typeof EAVIngest: ' + testResult);

        if (testResult === 'undefined') {
          addDebug('[ClipBrowser]  EAVIngest undefined!', true);
          self.showEmptyState('ExtendScript not loaded');
          return;
        }

        addDebug('[ClipBrowser]  EAVIngest available');
        addDebug('[ClipBrowser] Calling getAllProjectClips...');

        csInterface.evalScript('EAVIngest.getAllProjectClips()', function(result) {
          try {
            const data = JSON.parse(result);

            if (data.error) {
              addDebug('[ClipBrowser]  Error: ' + data.error, true);
              self.showEmptyState(data.error);
              return;
            }

            if (data.clips && data.clips.length > 0) {
              // Filter out any clips without nodeId
              const validClips = data.clips.filter(function(clip) {
                return clip.nodeId ? true : false;
              });

              if (validClips.length === 0) {
                addDebug('[ClipBrowser]  No valid clips found', true);
                self.showEmptyState('No valid clips in project');
                return;
              }

              PanelState.allClips = validClips;
              addDebug('[ClipBrowser]  Loaded ' + validClips.length + ' clips');

              // DEBUG: Show first clip structure
              if (validClips.length > 0) {
                addDebug('[ClipBrowser] === FIRST CLIP DEBUG ===');
                const firstClip = validClips[0];
                addDebug('[ClipBrowser] name: "' + (firstClip.name || 'EMPTY') + '"');
                addDebug('[ClipBrowser] treePath: "' + (firstClip.treePath || 'EMPTY') + '"');
                addDebug('[ClipBrowser] identifier: "' + (firstClip.identifier || 'EMPTY') + '"');
                addDebug('[ClipBrowser] description: "' + (firstClip.description || 'EMPTY') + '"');
                addDebug('[ClipBrowser] rawLogComment: "' + (firstClip.rawLogComment || 'EMPTY') + '"');
                addDebug('[ClipBrowser] regexAttempt: "' + (firstClip.regexAttempt || 'EMPTY') + '"');
                addDebug('[ClipBrowser] logCommentContext: "' + (firstClip.logCommentContext || 'EMPTY') + '"');
                addDebug('[ClipBrowser] availableColumns: "' + (firstClip.availableColumns || 'EMPTY') + '"');
                addDebug('[ClipBrowser] xmpSnippet: "' + (firstClip.xmpSnippet || 'EMPTY').substring(0, 200) + '..."');
                addDebug('[ClipBrowser] good: "' + (firstClip.good || 'EMPTY') + '"');
                addDebug('[ClipBrowser] shot: "' + (firstClip.shot || 'EMPTY') + '"');
                addDebug('[ClipBrowser] === END DEBUG ===');
              }

              self.render();

              // Auto-select first clip if none selected
              if (!PanelState.currentClip && validClips.length > 0) {
                addDebug('[ClipBrowser] Auto-selecting first clip');
                self.selectClip(validClips[0].nodeId);
              }
            } else {
              addDebug('[ClipBrowser] No clips found in project');
              self.showEmptyState('No clips in project');
            }
          } catch (e) {
            addDebug('[ClipBrowser]  JSON Parse error: ' + e.message, true);
            self.showEmptyState('Failed to load clips');
          }
        });
      });
    },

    render: function() {
      const filteredClips = this.getFilteredClips();

      if (filteredClips.length === 0) {
        this.showEmptyState('No clips match filters');
        return;
      }

      // Apply sorting
      const sortedClips = this.sortClips(filteredClips);

      const html = sortedClips.map(function(item) {
        // Check if this is a bin header
        if (item.isBinHeader) {
          // binPath is now just the bin name (e.g., "shoot1-20251024" or "Other")
          const binName = escapeHTML(item.binPath);
          return '<div class="bin-header" data-bin-path="' + binName + '">' +
                           binName +
                           '</div>';
        }

        // Regular clip item
        const clip = item;

        // Skip clips without nodeId (safety check)
        if (!clip.nodeId) {return '';}

        const isSelected = PanelState.currentClip && clip.nodeId === PanelState.currentClip.nodeId;
        const isChecked = PanelState.selectedClips.indexOf(clip.nodeId) !== -1;
        const hasMetadata = clip.shot || clip.description || clip.identifier;
        const statusIcon = hasMetadata ? '' : '';
        const statusClass = hasMetadata ? 'tagged' : 'untagged';

        // Add 'in-bin' class if we're in bin grouping mode
        const inBinClass = (PanelState.sortBy === 'bin') ? ' in-bin' : '';

        // Escape clip name for XSS prevention
        const safeName = escapeHTML(clip.name || 'Unknown');

        return '<div class="clip-item' + inBinClass +
                       (isSelected ? ' selected' : '') +
                       (isChecked ? ' checked' : '') + '" ' +
                       'data-clip-id="' + clip.nodeId + '" ' +
                       'role="listitem" tabindex="0">' +
                       '<input type="checkbox" class="clip-checkbox" ' + (isChecked ? 'checked' : '') + '>' +
                       '<span class="status-icon ' + statusClass + '">' + statusIcon + '</span>' +
                       '<span class="clip-name" title="' + safeName + '">' + safeName + '</span>' +
                       '</div>';
      }).join('');

      this.elements.clipList.innerHTML = html;

      // Count actual clips (exclude bin headers)
      const clipCount = sortedClips.filter(function(item) {
        return !item.isBinHeader;
      }).length;
      this.elements.clipCount.textContent = clipCount + ' clip' + (clipCount === 1 ? '' : 's');

      // Update selection UI
      this.updateSelectionUI();
    },

    getFilteredClips: function() {
      const search = PanelState.searchFilter.toLowerCase();

      return PanelState.allClips.filter(function(clip) {
        // Search filter
        if (search && clip.name.toLowerCase().indexOf(search) === -1) {
          return false;
        }

        // Type filters (basic heuristic: check file extension)
        const isVideo = /\.(mov|mp4|mxf|avi)$/i.test(clip.mediaPath);
        const isImage = /\.(jpg|jpeg|png|tif|tiff)$/i.test(clip.mediaPath);

        if (isVideo && !PanelState.filterVideo) {return false;}
        if (isImage && !PanelState.filterImage) {return false;}

        // Metadata filter
        const hasMetadata = clip.shot || clip.description || clip.identifier;
        if (PanelState.filterHasMeta && !hasMetadata) {return false;}

        return true;
      });
    },

    sortClips: function(clips) {
      // Apply sort based on PanelState.sortBy
      let sorted = clips.slice(); // Copy array to avoid mutation

      switch (PanelState.sortBy) {
      case 'name':
        // Alphabetical A-Z
        sorted.sort(function(a, b) {
          return a.name.localeCompare(b.name);
        });
        break;

      case 'name-desc':
        // Reverse alphabetical Z-A
        sorted.sort(function(a, b) {
          return b.name.localeCompare(a.name);
        });
        break;

      case 'bin':
        // Group by bin with headers
        sorted = this.groupByBin(sorted);
        break;

      default:
        // No sorting, return as-is
        break;
      }

      return sorted;
    },

    groupByBin: function(clips) {
      // Group clips by bin name extracted from treePath
      const grouped = {};
      const self = this;

      clips.forEach(function(clip) {
        let binName = 'Other'; // Default for clips without bin

        if (clip.treePath) {
          // treePath format: \ProjectName\BinName\FileName
          // Example: \EAV014 - PH Video.prproj\shoot1-20251024\EA001676.MOV
          let parts = clip.treePath.split('\\'); // Split by backslash

          // Remove empty strings from leading backslash
          parts = parts.filter(function(p) { return p.length > 0; });

          // parts[0] = ProjectName (e.g., "EAV014 - PH Video.prproj")
          // parts[1] = BinName (e.g., "shoot1-20251024" or "Stock")
          // parts[2] = FileName (e.g., "EA001676.MOV")

          if (parts.length >= 3) {
            // Has bin: use second segment (index 1)
            binName = parts[1];
          } else if (parts.length === 2) {
            // No bin: clip at project root
            binName = 'Other';
          }
        }

        if (!grouped[binName]) {
          grouped[binName] = [];
        }
        grouped[binName].push(clip);
      });

      // Sort bin names alphabetically
      const sortedBinNames = Object.keys(grouped).sort(function(a, b) {
        return a.localeCompare(b);
      });

      // Flatten to array with bin headers
      const result = [];
      sortedBinNames.forEach(function(binName) {
        // Add bin header
        result.push({
          isBinHeader: true,
          binPath: binName // Just the bin name, not full path
        });

        // Sort clips within bin alphabetically
        const binClips = grouped[binName];
        binClips.sort(function(a, b) {
          return a.name.localeCompare(b.name);
        });

        // Add clips
        binClips.forEach(function(clip) {
          result.push(clip);
        });
      });

      return result;
    },

    syncSelection: function(nodeId) {
      // Selection update for external navigation (updates UI + Source Monitor, no event dispatch)
      addDebug('[ClipBrowser] Syncing selection: ' + nodeId);

      // Validate nodeId
      if (!nodeId || nodeId === 'undefined' || nodeId === 'null') {
        addDebug('[ClipBrowser]  Invalid nodeId for sync', true);
        return;
      }

      const clip = PanelState.allClips.find(function(c) { return c.nodeId === nodeId; });
      if (!clip) {
        addDebug('[ClipBrowser]  Clip not found for sync', true);
        return;
      }

      // Check if already selected (avoid redundant work)
      if (PanelState.currentClip && PanelState.currentClip.nodeId === nodeId) {
        addDebug('[ClipBrowser]  Already selected, skipping sync');
        return;
      }

      const index = PanelState.allClips.indexOf(clip);
      PanelState.currentClip = clip;
      PanelState.currentClipIndex = index;

      addDebug('[ClipBrowser]  Synced selection: ' + clip.name);

      // Re-render to update selection UI (highlights clip)
      this.render();

      // Open in Source Monitor (user expects to see the clip)
      this.openInSourceMonitor(clip.nodeId);

      // Do NOT dispatch event (prevents infinite loops)
    },

    selectClip: function(nodeId) {
      addDebug('[ClipBrowser] Selecting clip: ' + nodeId);

      // Validate nodeId
      if (!nodeId || nodeId === 'undefined' || nodeId === 'null') {
        addDebug('[ClipBrowser]  Invalid nodeId', true);
        return;
      }

      const clip = PanelState.allClips.find(function(c) { return c.nodeId === nodeId; });
      if (!clip) {
        addDebug('[ClipBrowser]  Clip not found', true);
        return;
      }

      // Double-check clip has valid nodeId
      if (!clip.nodeId) {
        addDebug('[ClipBrowser]  Clip has no nodeId', true);
        return;
      }

      const index = PanelState.allClips.indexOf(clip);
      PanelState.currentClip = clip;
      PanelState.currentClipIndex = index;

      // Calculate position in FILTERED AND SORTED list (what user actually sees)
      const filteredClips = this.getFilteredClips();
      const sortedClips = this.sortClips(filteredClips);

      // Remove bin headers from sorted list (only actual clips for navigation)
      const sortedClipsOnly = sortedClips.filter(function(item) {
        return !item.isBinHeader;
      });

      const sortedIndex = sortedClipsOnly.indexOf(clip);
      const totalSorted = sortedClipsOnly.length;

      addDebug('[ClipBrowser]  Selected: ' + clip.name + ' (index: ' + sortedIndex + '/' + totalSorted + ')');

      // Emit CEP event for other extensions (e.g., Metadata Panel)
      try {
        const event = new CSEvent('com.elevana.clip-selected', 'APPLICATION');
        // Send clip data + navigation context with SORTED clips
        event.data = JSON.stringify({
          clip: clip,
          clipIndex: sortedIndex,
          totalClips: totalSorted,
          filteredClips: sortedClipsOnly // Send SORTED clips (matching visual order)
        });
        csInterface.dispatchEvent(event);
        addDebug('[ClipBrowser]  CEP event dispatched (index: ' + sortedIndex + '/' + totalSorted + ')');
      } catch (e) {
        addDebug('[ClipBrowser]  Failed to dispatch CEP event: ' + e.message, true);
      }

      // Re-render to update selection UI
      this.render();

      // AUTO-OPEN IN SOURCE MONITOR
      this.openInSourceMonitor(clip.nodeId);
    },

    openInSourceMonitor: function(nodeId) {
      addDebug('[ClipBrowser] Opening in Source Monitor: ' + nodeId);

      // SECURITY: Escape nodeId to prevent code injection
      const escapedNodeId = escapeForEvalScript(nodeId);
      csInterface.evalScript('EAVIngest.openInSourceMonitor("' + escapedNodeId + '")', function(result) {
        try {
          const data = JSON.parse(result);

          if (data.success) {
            addDebug('[ClipBrowser]  Opened in Source Monitor');
          } else {
            addDebug('[ClipBrowser]  Failed to open: ' + (data.error || 'Unknown error'), true);
          }
        } catch (e) {
          addDebug('[ClipBrowser]  Error opening: ' + e.message, true);
        }
      });
    },

    toggleClipSelection: function(nodeId) {
      const index = PanelState.selectedClips.indexOf(nodeId);
      if (index === -1) {
        // Add to selection
        PanelState.selectedClips.push(nodeId);
        addDebug('[ClipBrowser]  Clip selected for batch: ' + nodeId);
      } else {
        // Remove from selection
        PanelState.selectedClips.splice(index, 1);
        addDebug('[ClipBrowser] Clip deselected: ' + nodeId);
      }
      this.render(); // Re-render to update checkboxes and UI
    },

    selectAllClips: function() {
      const filteredClips = this.getFilteredClips();
      PanelState.selectedClips = filteredClips.map(function(clip) {
        return clip.nodeId;
      });
      addDebug('[ClipBrowser]  Selected all clips: ' + PanelState.selectedClips.length);
      this.render();
    },

    clearSelection: function() {
      const count = PanelState.selectedClips.length;
      PanelState.selectedClips = [];
      addDebug('[ClipBrowser] Selection cleared: ' + count + ' clips');
      this.render();
    },

    updateSelectionUI: function() {
      const count = PanelState.selectedClips.length;
      this.elements.selectedCount.textContent = count + ' selected';
      this.elements.batchApply.disabled = (count === 0);
    },

    batchApplyToPremiere: function() {
      const self = this;
      const selectedCount = PanelState.selectedClips.length;

      if (selectedCount === 0) {
        addDebug('[ClipBrowser]  No clips selected for batch apply', true);
        return;
      }

      addDebug('[ClipBrowser]  Starting batch apply: ' + selectedCount + ' clips');

      // Disable batch apply button and show processing state
      this.elements.batchApply.disabled = true;
      this.elements.batchApply.classList.add('processing');
      this.elements.batchApply.innerHTML = '<span class="batch-icon"></span> Processing...';

      // Get clip data for all selected clips
      const selectedClipData = PanelState.selectedClips.map(function(nodeId) {
        return PanelState.allClips.find(function(clip) {
          return clip.nodeId === nodeId;
        });
      }).filter(function(clip) {
        return clip !== null; // Remove any nulls
      });

      let processedCount = 0;
      let errorCount = 0;

      // Process each clip sequentially
      function processNextClip(index) {
        if (index >= selectedClipData.length) {
          // All done!
          addDebug('[ClipBrowser]  Batch apply complete: ' +
                             processedCount + ' succeeded, ' + errorCount + ' failed');

          // Reset button state
          self.elements.batchApply.classList.remove('processing');
          self.elements.batchApply.innerHTML = '<span class="batch-icon"></span> Batch Apply to Premiere';
          self.elements.batchApply.disabled = false;

          // Clear selection
          self.clearSelection();

          // Refresh clip list to show updated names
          self.loadAllClips();
          return;
        }

        const clip = selectedClipData[index];
        addDebug('[ClipBrowser] Processing (' + (index + 1) + '/' + selectedClipData.length + '): ' + clip.name);

        // Update progress in button
        self.elements.batchApply.innerHTML =
                    '<span class="batch-icon"></span> Processing ' + (index + 1) + '/' + selectedClipData.length;

        // Build metadata object from clip's existing XMP data
        const metadata = {
          name: clip.shot ? (clip.location + '-' + clip.subject + '-' + clip.action + '-' + clip.shot).replace(/^-+|-+$/g, '') : clip.name,
          identifier: clip.identifier || clip.name,
          description: clip.description || '',
          shot: clip.shot || '',
          good: clip.good || 'false',
          location: clip.location || '',
          subject: clip.subject || '',
          action: clip.action || ''
        };

        // Call ExtendScript to update Premiere
        const metadataJson = JSON.stringify(metadata);
        const escapedNodeId = escapeForEvalScript(clip.nodeId);
        const escapedMetadataJson = metadataJson.replace(/'/g, '\\\'');
        const script = 'EAVIngest.updateClipMetadata("' + escapedNodeId + '", JSON.parse(\'' + escapedMetadataJson + '\'))';

        csInterface.evalScript(script, function(result) {
          try {
            const data = JSON.parse(result);

            if (data.success) {
              processedCount++;
              addDebug('[ClipBrowser]  Applied: ' + data.updatedName);
            } else {
              errorCount++;
              addDebug('[ClipBrowser]  Failed: ' + data.error, true);
            }
          } catch (e) {
            errorCount++;
            addDebug('[ClipBrowser]  Error: ' + e.message, true);
          }

          // Process next clip after a small delay to avoid overwhelming Premiere
          setTimeout(function() {
            processNextClip(index + 1);
          }, 100); // 100ms delay between clips
        });
      }

      // Start processing
      processNextClip(0);
    },

    showEmptyState: function(message) {
      this.elements.clipList.innerHTML =
                '<div class="clip-list-empty">' +
                '<p>' + message + '</p>' +
                '</div>';
      this.elements.clipCount.textContent = '0 clips';
      this.updateSelectionUI(); // Update selection UI even when empty
    }
  };

  // ========================================
  // INITIALIZATION
  // ========================================

  function init() {
    addDebug('=== Navigation Panel Initializing ===');

    // Initialize Debug Panel clear button
    const clearDebugBtn = document.getElementById('clearDebug');
    if (clearDebugBtn) {
      clearDebugBtn.addEventListener('click', clearDebug);
      addDebug(' Debug panel ready');
    }

    // Initialize ClipBrowser
    ClipBrowser.init();
    addDebug(' ClipBrowser initialized');

    addDebug('=== Navigation Panel Ready ===');
  }

  // Start when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

})();
</file>

<file path="js/panel-main.js">
/**
 * EAV Ingest Assistant - Three-Panel Self-Contained Architecture
 * Components: ClipBrowser | ThumbnailViewer | MetadataForm
 */

// IMMEDIATE LOAD CONFIRMATION - This alert proves new code is executing
alert(' NEW panel-main.js loaded - Cache cleared successfully!');

// DIAGNOSTIC OVERLAY - Write directly to DOM
function addDiagnostic(message, isError) {
  let overlay = document.getElementById('diagnosticOverlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'diagnosticOverlay';
    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;background:#000;color:#0f0;padding:10px;font-family:monospace;font-size:11px;z-index:9999;max-height:200px;overflow-y:auto;border-bottom:2px solid #0f0;';
    document.body.appendChild(overlay);
  }
  const line = document.createElement('div');
  line.textContent = new Date().toTimeString().substr(0,8) + ' ' + message;
  line.style.color = isError ? '#f00' : '#0f0';
  overlay.appendChild(line);
}

addDiagnostic(' Panel-main.js executing...');

// ========================================
// SECURITY: String escaping for evalScript
// ========================================

/**
 * Escape a string for safe use in evalScript string concatenation
 * Prevents code injection by escaping quotes and backslashes
 * @param {string} str - The string to escape
 * @returns {string} - Escaped string safe for evalScript
 */
function escapeForEvalScript(str) {
  if (!str) {return '';}
  return String(str)
    .replace(/\\/g, '\\\\')  // Escape backslashes first
    .replace(/"/g, '\\"')     // Escape double quotes
    .replace(/'/g, '\\\'')     // Escape single quotes
    .replace(/\n/g, '\\n')    // Escape newlines
    .replace(/\r/g, '\\r');   // Escape carriage returns
}

(function() {
  'use strict';

  addDiagnostic(' IIFE started');

  // ========================================
  // GLOBAL STATE
  // ========================================

  const PanelState = {
    allClips: [],              // All project clips
    currentClip: null,         // Currently selected clip
    currentClipIndex: -1,      // Index in allClips
    searchFilter: '',          // Search text
    filterVideo: true,         // Show videos
    filterImage: true,         // Show images
    filterHasMeta: false       // Show only tagged clips
  };

  addDiagnostic(' PanelState created');

  // Initialize CSInterface
  let csInterface;
  try {
    addDiagnostic('Attempting CSInterface initialization...');
    csInterface = new CSInterface();
    addDiagnostic(' CSInterface initialized: ' + typeof csInterface);
    addDiagnostic(' Version: ' + csInterface.getHostEnvironment().appVersion);
  } catch (e) {
    addDiagnostic(' CSInterface FAILED: ' + e.message, true);
    alert('Error: CSInterface not available. ' + e.message);
    return;
  }

  // ========================================
  // COMPONENT 1: CLIP BROWSER
  // ========================================

  const ClipBrowser = {
    elements: {
      searchInput: null,
      clearSearchBtn: null,
      filterVideo: null,
      filterImage: null,
      filterHasMeta: null,
      clipList: null,
      clipCount: null,
      refreshBtn: null
    },

    init: function() {
      addDiagnostic('[ClipBrowser] Starting init...');

      // Get DOM elements
      addDiagnostic('[ClipBrowser] Getting DOM elements...');
      this.elements = {
        searchInput: document.getElementById('clipSearch'),
        clearSearchBtn: document.getElementById('clearSearch'),
        filterVideo: document.getElementById('filterVideo'),
        filterImage: document.getElementById('filterImage'),
        filterHasMeta: document.getElementById('filterHasMeta'),
        clipList: document.getElementById('clipList'),
        clipCount: document.getElementById('clipCount'),
        refreshBtn: document.getElementById('refreshClips')
      };
      addDiagnostic('[ClipBrowser]  DOM elements retrieved');

      // Set up event listeners
      addDiagnostic('[ClipBrowser] Setting up event listeners...');
      this.setupEventListeners();
      addDiagnostic('[ClipBrowser]  Event listeners set up');

      // Load all clips from project
      addDiagnostic('[ClipBrowser] About to call loadAllClips()...');
      this.loadAllClips();
      addDiagnostic('[ClipBrowser]  loadAllClips() called');
    },

    setupEventListeners: function() {
      const self = this;

      // Search input
      this.elements.searchInput.addEventListener('input', function(e) {
        PanelState.searchFilter = e.target.value;
        self.render();
      });

      // Clear search
      this.elements.clearSearchBtn.addEventListener('click', function() {
        self.elements.searchInput.value = '';
        PanelState.searchFilter = '';
        self.render();
      });

      // Filters
      this.elements.filterVideo.addEventListener('change', function(e) {
        PanelState.filterVideo = e.target.checked;
        self.render();
      });

      this.elements.filterImage.addEventListener('change', function(e) {
        PanelState.filterImage = e.target.checked;
        self.render();
      });

      this.elements.filterHasMeta.addEventListener('change', function(e) {
        PanelState.filterHasMeta = e.target.checked;
        self.render();
      });

      // Refresh button
      this.elements.refreshBtn.addEventListener('click', function() {
        self.loadAllClips();
      });

      // Clip list click handling (event delegation)
      this.elements.clipList.addEventListener('click', function(e) {
        console.log('[ClipBrowser] ========== CLIP CLICKED ==========');
        console.log('[ClipBrowser] Click target:', e.target);

        const clipItem = e.target.closest('.clip-item');
        console.log('[ClipBrowser] Found clip-item element:', clipItem);

        if (clipItem) {
          const nodeId = clipItem.getAttribute('data-clip-id');
          console.log('[ClipBrowser] Clip nodeId:', nodeId);
          self.selectClip(nodeId);
        } else {
          console.warn('[ClipBrowser] No clip-item found in click target hierarchy');
        }
      });
    },

    loadAllClips: function() {
      const self = this;
      addDiagnostic('[ClipBrowser] === LOADING CLIPS ===');
      addDiagnostic('[ClipBrowser] csInterface type: ' + typeof csInterface);

      if (!csInterface) {
        addDiagnostic('[ClipBrowser]  csInterface not available!', true);
        self.showEmptyState('CSInterface not initialized');
        return;
      }

      // First test if ExtendScript is available
      addDiagnostic('[ClipBrowser] Testing ExtendScript...');
      csInterface.evalScript('typeof EAVIngest', function(testResult) {
        addDiagnostic('[ClipBrowser] typeof EAVIngest: ' + testResult);

        if (testResult === 'undefined') {
          addDiagnostic('[ClipBrowser]  EAVIngest undefined!', true);
          self.showEmptyState('ExtendScript not loaded');
          return;
        }

        addDiagnostic('[ClipBrowser]  EAVIngest available');
        addDiagnostic('[ClipBrowser] Calling getAllProjectClips...');

        csInterface.evalScript('EAVIngest.getAllProjectClips()', function(result) {
          addDiagnostic('[ClipBrowser] Callback fired! Result length: ' + (result ? result.length : 0));
          addDiagnostic('[ClipBrowser] First 100 chars: ' + (result ? result.substring(0,100) : 'null'));

          try {
            const data = JSON.parse(result);
            console.log('[ClipBrowser] getAllProjectClips parsed data:', data);

            if (data.error) {
              console.error('[ClipBrowser]  Error loading clips:', data.error);
              self.showEmptyState(data.error);
              return;
            }

            if (data.clips && data.clips.length > 0) {
              // Filter out any clips without nodeId
              const validClips = data.clips.filter(function(clip) {
                if (!clip.nodeId) {
                  console.warn('[ClipBrowser] Skipping clip without nodeId:', clip);
                  return false;
                }
                return true;
              });

              if (validClips.length === 0) {
                console.warn('[ClipBrowser] No valid clips found (all missing nodeId)');
                self.showEmptyState('No valid clips in project');
                return;
              }

              PanelState.allClips = validClips;
              console.log('[ClipBrowser]  Loaded', validClips.length, 'valid clips');
              console.log('[ClipBrowser] First clip:', validClips[0]);
              self.render();

              // Auto-select first clip if none selected
              if (!PanelState.currentClip && validClips.length > 0) {
                console.log('[ClipBrowser] Auto-selecting first clip with nodeId:', validClips[0].nodeId);
                self.selectClip(validClips[0].nodeId);
              }
            } else {
              console.warn('[ClipBrowser] No clips found in project');
              self.showEmptyState('No clips in project');
            }
          } catch (e) {
            console.error('[ClipBrowser]  JSON Parse error:', e);
            console.error('[ClipBrowser] Raw result was:', result);
            self.showEmptyState('Failed to load clips');
          }
        });
      });
    },

    render: function() {
      const filteredClips = this.getFilteredClips();

      if (filteredClips.length === 0) {
        this.showEmptyState('No clips match filters');
        return;
      }

      const html = filteredClips.map(function(clip) {
        // Skip clips without nodeId (safety check)
        if (!clip.nodeId) {
          console.warn('[ClipBrowser] Skipping render of clip without nodeId:', clip);
          return '';
        }

        const isSelected = PanelState.currentClip && clip.nodeId === PanelState.currentClip.nodeId;
        const hasMetadata = clip.shot || clip.description || clip.tapeName;
        const statusIcon = hasMetadata ? '' : '';
        const statusClass = hasMetadata ? 'tagged' : 'untagged';

        return '<div class="clip-item' + (isSelected ? ' selected' : '') + '" ' +
                       'data-clip-id="' + clip.nodeId + '" ' +
                       'role="listitem" tabindex="0">' +
                       '<span class="status-icon ' + statusClass + '">' + statusIcon + '</span>' +
                       '<span class="clip-name" title="' + (clip.name || 'Unknown') + '">' + (clip.name || 'Unknown') + '</span>' +
                       '</div>';
      }).join('');

      this.elements.clipList.innerHTML = html;
      this.elements.clipCount.textContent = filteredClips.length + ' clip' + (filteredClips.length === 1 ? '' : 's');
    },

    getFilteredClips: function() {
      const search = PanelState.searchFilter.toLowerCase();

      return PanelState.allClips.filter(function(clip) {
        // Search filter
        if (search && clip.name.toLowerCase().indexOf(search) === -1) {
          return false;
        }

        // Type filters (basic heuristic: check file extension)
        const isVideo = /\.(mov|mp4|mxf|avi)$/i.test(clip.mediaPath);
        const isImage = /\.(jpg|jpeg|png|tif|tiff)$/i.test(clip.mediaPath);

        if (isVideo && !PanelState.filterVideo) {return false;}
        if (isImage && !PanelState.filterImage) {return false;}

        // Metadata filter
        const hasMetadata = clip.shot || clip.description || clip.tapeName;
        if (PanelState.filterHasMeta && !hasMetadata) {return false;}

        return true;
      });
    },

    selectClip: function(nodeId) {
      console.log('[ClipBrowser] ========== SELECT CLIP ==========');
      console.log('[ClipBrowser] Selecting nodeId:', nodeId);

      // Validate nodeId
      if (!nodeId || nodeId === 'undefined' || nodeId === 'null') {
        console.error('[ClipBrowser]  Invalid nodeId:', nodeId);
        return;
      }

      console.log('[ClipBrowser] Total clips in state:', PanelState.allClips.length);

      const clip = PanelState.allClips.find(function(c) { return c.nodeId === nodeId; });
      if (!clip) {
        console.error('[ClipBrowser]  Clip not found for nodeId:', nodeId);
        return;
      }

      // Double-check clip has valid nodeId
      if (!clip.nodeId) {
        console.error('[ClipBrowser]  Found clip but it has no nodeId:', clip);
        return;
      }

      const index = PanelState.allClips.indexOf(clip);
      PanelState.currentClip = clip;
      PanelState.currentClipIndex = index;

      console.log('[ClipBrowser]  Selected clip:', clip.name, '(index:', index, ')');
      console.log('[ClipBrowser] Full clip object:', clip);

      // Emit custom event for other components
      console.log('[ClipBrowser] Dispatching clip-selected event...');
      document.dispatchEvent(new CustomEvent('clip-selected', {
        detail: clip
      }));

      // Re-render to update selection UI
      this.render();
    },

    showEmptyState: function(message) {
      this.elements.clipList.innerHTML =
                '<div class="clip-list-empty">' +
                '<p>' + message + '</p>' +
                '</div>';
      this.elements.clipCount.textContent = '0 clips';
    }
  };

  // ========================================
  // COMPONENT 2: THUMBNAIL VIEWER
  // ========================================

  const ThumbnailViewer = {
    elements: {
      placeholder: null,
      image: null,
      clipName: null,
      clipDetails: null,
      openSourceBtn: null,
      status: null
    },

    init: function() {
      console.log('[ThumbnailViewer] Initializing...');

      // Get DOM elements
      this.elements = {
        placeholder: document.getElementById('thumbnailPlaceholder'),
        image: document.getElementById('thumbnailImage'),
        clipName: document.getElementById('thumbnailClipName'),
        clipDetails: document.getElementById('thumbnailClipDetails'),
        openSourceBtn: document.getElementById('openSourceBtn'),
        status: document.getElementById('thumbnailStatus')
      };

      // Set up event listeners
      this.setupEventListeners();
    },

    setupEventListeners: function() {
      const self = this;

      // Listen for clip selection
      document.addEventListener('clip-selected', function(e) {
        console.log('[ThumbnailViewer] Received clip-selected event');
        console.log('[ThumbnailViewer] Event detail:', e.detail);
        self.loadClip(e.detail);
      });

      // Open in Source Monitor
      this.elements.openSourceBtn.addEventListener('click', function() {
        if (PanelState.currentClip) {
          self.openInSourceMonitor();
        }
      });
    },

    loadClip: function(clip) {
      const self = this;
      console.log('[ThumbnailViewer] ========== LOADING CLIP ==========');

      // Validate clip object
      if (!clip) {
        console.error('[ThumbnailViewer]  Clip is null or undefined');
        this.showStatus('Error: No clip provided', 'error');
        return;
      }

      if (!clip.nodeId) {
        console.error('[ThumbnailViewer]  Clip nodeId is missing');
        console.error('[ThumbnailViewer] Clip object:', clip);
        this.showStatus('Error: Invalid clip data', 'error');
        return;
      }

      console.log('[ThumbnailViewer] Clip name:', clip.name);
      console.log('[ThumbnailViewer] Clip nodeId:', clip.nodeId);
      console.log('[ThumbnailViewer] Clip treePath:', clip.treePath);

      // Show placeholder (no thumbnail needed - using Source Monitor)
      this.elements.placeholder.style.display = 'flex';
      this.elements.image.style.display = 'none';

      // Update clip info
      this.elements.clipName.textContent = clip.name || 'Unknown';
      this.elements.clipDetails.textContent = clip.treePath || 'Project';

      // Enable buttons
      this.elements.openSourceBtn.disabled = false;

      console.log('[ThumbnailViewer] Buttons enabled');

      // AUTO-OPEN IN SOURCE MONITOR (instead of frame extraction)
      this.showStatus('Opening in Source Monitor...', 'info');
      console.log('[ThumbnailViewer] Calling openInSourceMonitor with nodeId:', clip.nodeId);

      // SECURITY: Escape nodeId to prevent code injection
      const escapedNodeId = escapeForEvalScript(clip.nodeId);
      csInterface.evalScript('EAVIngest.openInSourceMonitor("' + escapedNodeId + '")', function(result) {
        console.log('[ThumbnailViewer] openInSourceMonitor raw result:', result);

        try {
          const data = JSON.parse(result);
          console.log('[ThumbnailViewer] openInSourceMonitor parsed data:', data);

          if (data.success) {
            console.log('[ThumbnailViewer]  Opened in Source Monitor successfully');
            self.showStatus(' Opened in Source Monitor', 'success');
          } else {
            console.error('[ThumbnailViewer]  Failed to open:', data.error);
            self.showStatus('Error: ' + (data.error || 'Unknown error'), 'error');
          }
        } catch (e) {
          console.error('[ThumbnailViewer]  JSON Parse error:', e);
          console.error('[ThumbnailViewer] Raw result was:', result);
          self.showStatus('Failed to open in Source Monitor', 'error');
        }
      });
    },

    displayFrame: function(framePath) {
      // Convert to file:// URL
      const fileUrl = this.formatFileUrl(framePath);
      console.log('[ThumbnailViewer] Displaying frame:', fileUrl);

      // Hide placeholder, show image
      this.elements.placeholder.style.display = 'none';
      this.elements.image.style.display = 'block';

      // Set image source
      this.elements.image.src = fileUrl;
    },

    formatFileUrl: function(filePath) {
      // Cross-platform path normalization
      let normalized = filePath;

      // Convert backslashes to forward slashes (Windows)
      normalized = normalized.replace(/\\/g, '/');

      // Ensure file:// protocol
      if (!normalized.startsWith('file://')) {
        // macOS/Linux absolute paths start with /
        if (normalized.startsWith('/')) {
          normalized = 'file://' + normalized;
        }
        // Windows paths start with drive letter (C:/)
        else if (normalized.match(/^[A-Z]:\//i)) {
          normalized = 'file:///' + normalized;
        }
      }

      // URL encode special characters
      normalized = normalized.replace(/#/g, '%23')
        .replace(/\?/g, '%3F')
        .replace(/\s/g, '%20');

      return normalized;
    },

    openInSourceMonitor: function() {
      const self = this;

      if (!PanelState.currentClip) {return;}

      console.log('[ThumbnailViewer] Opening in Source Monitor:', PanelState.currentClip.name);

      // SECURITY: Escape nodeId to prevent code injection
      const escapedNodeId = escapeForEvalScript(PanelState.currentClip.nodeId);
      csInterface.evalScript('EAVIngest.openInSourceMonitor("' + escapedNodeId + '")', function(result) {
        try {
          const data = JSON.parse(result);

          if (data.success) {
            self.showStatus('Opened in Source Monitor', 'success');
          } else {
            self.showStatus('Error: ' + (data.error || 'Unknown error'), 'error');
          }
        } catch (e) {
          console.error('[ThumbnailViewer] Error opening in Source Monitor:', e);
          self.showStatus('Failed to open in Source Monitor', 'error');
        }
      });
    },

    showStatus: function(message, type) {
      this.elements.status.textContent = message;
      this.elements.status.className = 'thumbnail-status ' + type;

      // Auto-clear success/info messages
      if (type === 'success' || type === 'info') {
        setTimeout(function() {
          this.elements.status.textContent = '';
          this.elements.status.className = 'thumbnail-status';
        }.bind(this), 3000);
      }
    }
  };

  // ========================================
  // COMPONENT 3: METADATA FORM
  // ========================================

  const MetadataForm = {
    elements: {
      formClipName: null,
      id: null,
      location: null,
      subject: null,
      action: null,
      shotType: null,
      metadata: null,
      actionGroup: null,
      generatedName: null,
      prevBtn: null,
      nextBtn: null,
      applyBtn: null,
      status: null
    },

    init: function() {
      console.log('[MetadataForm] Initializing...');

      // Get DOM elements
      this.elements = {
        formClipName: document.getElementById('formClipName'),
        id: document.getElementById('id'),
        location: document.getElementById('location'),
        subject: document.getElementById('subject'),
        action: document.getElementById('action'),
        shotType: document.getElementById('shotType'),
        metadata: document.getElementById('metadata'),
        actionGroup: document.getElementById('actionGroup'),
        generatedName: document.getElementById('generatedName'),
        prevBtn: document.getElementById('prevBtn'),
        nextBtn: document.getElementById('nextBtn'),
        applyBtn: document.getElementById('applyBtn'),
        status: document.getElementById('formStatus')
      };

      // Set up event listeners
      this.setupEventListeners();
    },

    setupEventListeners: function() {
      const self = this;

      // Listen for clip selection
      document.addEventListener('clip-selected', function(e) {
        console.log('[MetadataForm] Received clip-selected event');
        console.log('[MetadataForm] Event detail:', e.detail);
        self.loadClipIntoForm(e.detail);
      });

      // Form field changes - update preview
      this.elements.location.addEventListener('input', function() { self.updateGeneratedName(); });
      this.elements.subject.addEventListener('input', function() { self.updateGeneratedName(); });
      this.elements.action.addEventListener('input', function() { self.updateGeneratedName(); });
      this.elements.shotType.addEventListener('change', function() { self.updateGeneratedName(); });

      // Navigation buttons
      this.elements.prevBtn.addEventListener('click', function() {
        self.navigateToPrevious();
      });

      this.elements.nextBtn.addEventListener('click', function() {
        self.navigateToNext();
      });

      // Apply button
      this.elements.applyBtn.addEventListener('click', function() {
        self.applyMetadata();
      });
    },

    loadClipIntoForm: function(clip) {
      console.log('[MetadataForm] ========== LOADING CLIP INTO FORM ==========');

      // Validate clip object
      if (!clip) {
        console.error('[MetadataForm]  Clip is null or undefined');
        return;
      }

      if (!clip.nodeId) {
        console.error('[MetadataForm]  Clip nodeId is missing');
        console.error('[MetadataForm] Clip object:', clip);
        return;
      }

      console.log('[MetadataForm] Clip name:', clip.name);
      console.log('[MetadataForm] Clip nodeId:', clip.nodeId);

      // Update header
      this.elements.formClipName.textContent = clip.name;

      // Parse ID from filename (8-digit pattern)
      const idMatch = clip.name.match(/^(\d{8})/);
      this.elements.id.value = idMatch ? idMatch[1] : '';

      // Parse structured components from name
      const components = this.parseStructuredComponents(clip.name);

      this.elements.location.value = components.location || '';
      this.elements.subject.value = components.subject || '';
      this.elements.action.value = components.action || '';
      this.elements.shotType.value = components.shotType || '';

      // Load Description field as metadata tags
      this.elements.metadata.value = clip.description || '';

      // Show/hide action field based on type (heuristic: video files have action)
      const isVideo = /\.(mov|mp4|mxf|avi)$/i.test(clip.mediaPath);
      this.elements.actionGroup.style.display = isVideo ? 'block' : 'none';

      // Update generated name preview
      this.updateGeneratedName();

      // Enable buttons
      this.elements.applyBtn.disabled = false;
      this.updateNavigationButtons();
    },

    parseStructuredComponents: function(name) {
      // Remove extension
      const nameWithoutExt = name.replace(/\.[^.]+$/, '');

      // Split by hyphen
      const parts = nameWithoutExt.split('-');

      if (parts.length < 2) {
        return {};
      }

      const components = {};

      if (parts.length >= 5) {
        // Video format: id-location-subject-action-shotType
        components.location = parts[1] || '';
        components.subject = parts[2] || '';
        components.action = parts[3] || '';
        components.shotType = parts[4] || '';
      } else if (parts.length === 4) {
        // Image format: id-location-subject-shotType
        components.location = parts[1] || '';
        components.subject = parts[2] || '';
        components.shotType = parts[3] || '';
      }

      return components;
    },

    updateGeneratedName: function() {
      const id = this.elements.id.value;
      const location = this.elements.location.value.trim();
      const subject = this.elements.subject.value.trim();
      const action = this.elements.action.value.trim();
      const shotType = this.elements.shotType.value;

      const parts = [];

      if (id) {parts.push(id);}
      if (location) {parts.push(location);}
      if (subject) {parts.push(subject);}

      // Include action only if visible (videos)
      if (this.elements.actionGroup.style.display !== 'none' && action) {
        parts.push(action);
      }

      if (shotType) {parts.push(shotType);}

      const generatedName = parts.length > 0 ? parts.join('-') : '-';
      this.elements.generatedName.textContent = generatedName;
    },

    applyMetadata: function() {
      const self = this;
      console.log('[MetadataForm] ========== APPLY METADATA ==========');

      if (!PanelState.currentClip) {
        console.error('[MetadataForm]  No clip selected');
        this.showStatus('No clip selected', 'error');
        return;
      }

      console.log('[MetadataForm] Current clip:', PanelState.currentClip.name);
      console.log('[MetadataForm] Current clip nodeId:', PanelState.currentClip.nodeId);

      // Build the generated name
      const generatedName = this.elements.generatedName.textContent;
      console.log('[MetadataForm] Generated name:', generatedName);

      if (generatedName === '-') {
        console.error('[MetadataForm]  No fields filled in');
        this.showStatus('Please fill in at least one field', 'error');
        return;
      }

      // Prepare metadata object
      const metadata = {
        name: generatedName,
        tapeName: PanelState.currentClip.name, // Preserve original filename
        description: this.elements.metadata.value.trim(),
        shot: this.elements.shotType.value
      };

      console.log('[MetadataForm] Metadata object:', metadata);

      this.showStatus('Updating Premiere Pro...', 'info');

      // Call ExtendScript to update PP
      // Properly format the metadata object for ExtendScript using JSON.parse with single quotes
      const metadataJson = JSON.stringify(metadata);
      console.log('[MetadataForm] Metadata JSON:', metadataJson);

      const script = 'EAVIngest.updateClipMetadata("' + PanelState.currentClip.nodeId + '", JSON.parse(\'' + metadataJson.replace(/'/g, '\\\'') + '\'))';
      console.log('[MetadataForm] ExtendScript to execute:', script);

      csInterface.evalScript(script, function(result) {
        console.log('[MetadataForm] updateClipMetadata raw result:', result);

        try {
          const data = JSON.parse(result);
          console.log('[MetadataForm] updateClipMetadata parsed data:', data);

          if (data.success) {
            console.log('[MetadataForm]  Metadata updated successfully');
            console.log('[MetadataForm] Updated name:', data.updatedName);
            self.showStatus(' Updated: ' + data.updatedName, 'success');

            // Update current clip name in state
            PanelState.currentClip.name = data.updatedName;

            // Emit event to update clip browser
            document.dispatchEvent(new CustomEvent('metadata-applied', {
              detail: { nodeId: PanelState.currentClip.nodeId }
            }));

            // Optionally auto-advance to next clip
            // setTimeout(function() { self.navigateToNext(); }, 1000);
          } else {
            console.error('[MetadataForm]  Update failed:', data.error);
            self.showStatus('Error: ' + (data.error || 'Unknown error'), 'error');
          }
        } catch (e) {
          console.error('[MetadataForm]  JSON Parse error:', e);
          console.error('[MetadataForm] Raw result was:', result);
          self.showStatus('Error updating Premiere Pro', 'error');
        }
      });
    },

    navigateToPrevious: function() {
      if (PanelState.currentClipIndex > 0) {
        const prevClip = PanelState.allClips[PanelState.currentClipIndex - 1];
        ClipBrowser.selectClip(prevClip.nodeId);
      }
    },

    navigateToNext: function() {
      if (PanelState.currentClipIndex < PanelState.allClips.length - 1) {
        const nextClip = PanelState.allClips[PanelState.currentClipIndex + 1];
        ClipBrowser.selectClip(nextClip.nodeId);
      }
    },

    updateNavigationButtons: function() {
      this.elements.prevBtn.disabled = PanelState.currentClipIndex <= 0;
      this.elements.nextBtn.disabled = PanelState.currentClipIndex >= PanelState.allClips.length - 1 || PanelState.allClips.length === 0;
    },

    showStatus: function(message, type) {
      this.elements.status.textContent = message;
      this.elements.status.className = 'form-status ' + type;

      // Auto-clear success/info messages
      if (type === 'success' || type === 'info') {
        setTimeout(function() {
          this.elements.status.textContent = '';
          this.elements.status.className = 'form-status';
        }.bind(this), 3000);
      }
    }
  };

  // ========================================
  // PANEL INITIALIZATION
  // ========================================

  function init() {
    console.log('[Panel] ========================================');
    console.log('[Panel] Initializing Components...');
    console.log('[Panel] ========================================');

    // Initialize all components
    console.log('[Panel] 1. Initializing ClipBrowser...');
    ClipBrowser.init();
    console.log('[Panel] 2. Initializing ThumbnailViewer...');
    ThumbnailViewer.init();
    console.log('[Panel] 3. Initializing MetadataForm...');
    MetadataForm.init();

    console.log('[Panel] ========================================');
    console.log('[Panel]  All components initialized successfully');
    console.log('[Panel] ========================================');
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // ========================================
  // GLOBAL DEBUGGING INTERFACE (temporary)
  // ========================================
  window.EAVDebug = {
    state: PanelState,
    csInterface: csInterface,
    ClipBrowser: ClipBrowser,
    testExtendScript: function() {
      console.log('[DEBUG] Testing ExtendScript connection...');
      csInterface.evalScript('typeof EAVIngest', function(result) {
        console.log('[DEBUG] typeof EAVIngest:', result);
        if (result === 'object') {
          console.log('[DEBUG]  EAVIngest is available, testing getAllProjectClips...');
          csInterface.evalScript('EAVIngest.getAllProjectClips()', function(clipsResult) {
            console.log('[DEBUG] === RAW RESULT ===');
            console.log('[DEBUG] Type:', typeof clipsResult);
            console.log('[DEBUG] Length:', clipsResult.length);
            console.log('[DEBUG] First 500 chars:', clipsResult.substring(0, 500));
            console.log('[DEBUG] Full result:', clipsResult);
            try {
              const parsed = JSON.parse(clipsResult);
              console.log('[DEBUG]  Valid JSON, parsed:', parsed);
            } catch (e) {
              console.error('[DEBUG]  JSON parse failed:', e);
            }
          });
        } else {
          console.error('[DEBUG]  EAVIngest not available:', result);
        }
      });
    }
  };
  console.log('[Panel] ========================================');
  console.log('[Panel] Global EAVDebug interface exposed');
  console.log('[Panel] Run: EAVDebug.testExtendScript()');
  console.log('[Panel] Check: EAVDebug.state.allClips');
  console.log('[Panel] ========================================');

})();
</file>

<file path="jsx/host.jsx">
// ExtendScript for Premiere Pro

// Handles communication between the CEP panel and Premiere Pro



var EAVIngest = (function() {

  'use strict';



  /**

     * Log to file for debugging (when console not available)

     */

  function logToFile(message) {

    try {

      // Use user data directory instead of desktop for privacy
      // Creates ~/.debug/ directory if it doesn't exist
      var debugDir = new Folder(Folder.userData.parent.fsName + '/.debug');
      if (!debugDir.exists) {
        debugDir.create();
      }

      var logFile = new File(debugDir.fsName + '/eav-cep-debug.txt');

      logFile.open('a'); // append mode

      logFile.writeln(new Date().toISOString() + ' - ' + message);

      logFile.close();

    } catch (e) {

      // Silently fail if file write errors

    }

    // Also write to console (if available)

    $.writeln(message);

  }



  /**

     * Escape XML entities to prevent injection attacks

     * @param {string} str - Raw string value

     * @returns {string} XML-safe escaped string

     */

  function escapeXML(str) {

    if (!str) {return '';}

    return String(str)

      .replace(/&/g, '&amp;')

      .replace(/</g, '&lt;')

      .replace(/>/g, '&gt;')

      .replace(/"/g, '&quot;')

      .replace(/'/g, '&apos;');

  }



  /**

     * Get currently selected project item(s) from Project Panel

     * Returns array of selected clips with their metadata

     */

  function getSelectedClips() {

    var project = app.project;

    if (!project) {

      return JSON.stringify({ error: 'No active project' });

    }



    var selection = project.getSelection();

    if (!selection || selection.length === 0) {

      return JSON.stringify({ error: 'No clips selected' });

    }



    var clips = [];

    for (var i = 0; i < selection.length; i++) {

      var item = selection[i];



      // Only process video/image items, not bins

      if (item.type === ProjectItemType.CLIP || item.type === ProjectItemType.FILE) {

        // DIAGNOSTIC: Test Project Columns access in getSelectedClips() context
        var projectCols = item.getProjectColumnsMetadata();
        var colTest = 'Tape=' + (projectCols.Tape || 'NONE') +
                      ' | Desc=' + (projectCols.Description || 'NONE') +
                      ' | Shot=' + (projectCols.Shot || 'NONE') +
                      ' | LogComment(space)=' + (projectCols['Log Comment'] || 'NONE') +
                      ' | LogComment(noSpace)=' + (projectCols.LogComment || 'NONE');
        $.writeln('DEBUG getSelectedClips() PROJECT COLUMNS: ' + colTest);

        clips.push({

          nodeId: item.nodeId,

          name: item.name || '',

          treePath: item.treePath || '',

          mediaPath: item.getMediaPath() || '',

          // Get existing metadata from PP fields

          tapeName: projectCols.Tape || '',

          description: projectCols.Description || '',

          shot: projectCols.Shot || '',

          // DIAGNOSTIC: Test if we can read Log Comment
          logCommentFromColumn: projectCols['Log Comment'] || projectCols.LogComment || 'NO_COLUMN_ACCESS',

          // File info

          videoFrameRate: item.getFootageInterpretation().frameRate || '',

          duration: item.getOutPoint().seconds || 0,

          type: item.type

        });

      }

    }



    if (clips.length === 0) {

      return JSON.stringify({ error: 'No video/image clips in selection' });

    }



    return JSON.stringify({ clips: clips });

  }



  /**

     * Update PP project item metadata fields

     * Updates: Name, Tape Name, Description, Shot

     */

  function updateClipMetadata(nodeId, metadata) {

    var debugLog = []; // Collect debug messages to return to CEP panel

    var project = app.project;

    if (!project) {

      return JSON.stringify({ success: false, error: 'No active project' });

    }



    // Find the project item by nodeId

    var item = findProjectItemByNodeId(project.rootItem, nodeId);

    if (!item) {

      return JSON.stringify({ success: false, error: 'Clip not found' });

    }



    try {

      // Update Name field (visible in Project Panel)

      if (metadata.name !== undefined) {

        item.name = metadata.name;

      }



      // Update metadata via XMP

      try {

        var xmpString = item.getXMPMetadata();

        debugLog.push('Got XMP (length: ' + xmpString.length + ')');

        debugLog.push('Incoming metadata:');

        debugLog.push('  description: \'' + metadata.description + '\'');

        debugLog.push('  location: \'' + metadata.location + '\'');

        debugLog.push('  subject: \'' + metadata.subject + '\'');

        debugLog.push('  action: \'' + metadata.action + '\'');

        debugLog.push('  shot: \'' + metadata.shot + '\'');



        // ========== DUBLIN CORE NAMESPACE FIELDS ==========

        // Collect all Dublin Core fields to update

        var dcFields = [];

        if (metadata.description !== undefined) {

          dcFields.push({

            tag: 'dc:description',

            value: '<dc:description><rdf:Alt><rdf:li xml:lang="x-default">' + escapeXML(metadata.description) + '</rdf:li></rdf:Alt></dc:description>',

            regex: /<dc:description[^>]*>[\s\S]*?<\/dc:description>/

          });

        }

        if (metadata.identifier !== undefined) {

          dcFields.push({

            tag: 'dc:identifier',

            value: '<dc:identifier>' + escapeXML(metadata.identifier) + '</dc:identifier>',

            regex: /<dc:identifier[^>]*>[\s\S]*?<\/dc:identifier>/

          });

        }



        // Update Dublin Core fields in their namespace block

        if (dcFields.length > 0) {

          // Find the Dublin Core rdf:Description block

          var dcBlockMatch = xmpString.match(/<rdf:Description[^>]*xmlns:dc="http:\/\/purl\.org\/dc\/elements\/1\.1\/"[^>]*>([\s\S]*?)<\/rdf:Description>/);



          if (dcBlockMatch) {

            // DC block exists - update fields within it

            var dcBlockContent = dcBlockMatch[1];

            var dcBlockFull = dcBlockMatch[0];



            for (var i = 0; i < dcFields.length; i++) {

              var field = dcFields[i];

              if (dcBlockContent.indexOf('<' + field.tag) > -1) {

                // Field exists - replace it

                debugLog.push(field.tag + ' FOUND, replacing...');

                var beforeReplace = dcBlockContent;

                dcBlockContent = dcBlockContent.replace(field.regex, field.value);

                if (beforeReplace === dcBlockContent) {

                  debugLog.push('ERROR: ' + field.tag + ' regex did NOT match!');

                } else {

                  debugLog.push(field.tag + ' successfully replaced');

                }

              } else {

                // Field doesn't exist - append it

                debugLog.push(field.tag + ' NOT FOUND, appending...');

                dcBlockContent += field.value;

              }

              debugLog.push(field.tag + ' updated');

            }



            // Replace the entire DC block with updated content

            // Extract just the opening tag (everything up to first '>')

            var openingTagEnd = dcBlockFull.indexOf('>') + 1;

            var openingTag = dcBlockFull.substring(0, openingTagEnd);

            var newDcBlock = openingTag + dcBlockContent + '</rdf:Description>';

            xmpString = xmpString.replace(dcBlockFull, newDcBlock);



          } else {

            // DC block doesn't exist - create it

            var dcBlock = '<rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">';

            for (var i = 0; i < dcFields.length; i++) {

              dcBlock += dcFields[i].value;

              $.writeln('DEBUG SAVE: ' + dcFields[i].tag + ' created');

            }

            dcBlock += '</rdf:Description>';



            // Insert before closing </rdf:RDF>

            xmpString = xmpString.replace(/<\/rdf:RDF>/, dcBlock + '</rdf:RDF>');

          }

        }



        // ========== XMPDM NAMESPACE FIELDS (IA COMPATIBILITY) ==========

        // Build combined shotName and structured LogComment

        var xmpDmFields = [];



        // Build shotName: location-subject-action-shotType (or without action for images)

        if (metadata.location && metadata.subject && metadata.shot) {

          var shotName = metadata.location + '-' + metadata.subject;

          if (metadata.action) {

            shotName += '-' + metadata.action;

          }

          shotName += '-' + metadata.shot;



          xmpDmFields.push({

            tag: 'xmpDM:shotName',

            value: '<xmpDM:shotName>' + escapeXML(shotName) + '</xmpDM:shotName>',

            regex: /<xmpDM:shotName[^>]*>[\s\S]*?<\/xmpDM:shotName>/

          });

        }



        // Build LogComment: location=X, subject=Y, action=Z, shotType=W

        if (metadata.location !== undefined && metadata.subject !== undefined && metadata.shot !== undefined) {

          var logComment = 'location=' + escapeXML(metadata.location || '') +

                                   ', subject=' + escapeXML(metadata.subject || '') +

                                   ', action=' + escapeXML(metadata.action || '') +

                                   ', shotType=' + escapeXML(metadata.shot || '');



          xmpDmFields.push({

            tag: 'xmpDM:LogComment',

            value: '<xmpDM:LogComment>' + logComment + '</xmpDM:LogComment>',

            regex: /<xmpDM:LogComment[^>]*>[\s\S]*?<\/xmpDM:LogComment>/

          });

        }



        // Update xmpDM fields in their namespace block

        if (xmpDmFields.length > 0) {

          // Find the xmpDM rdf:Description block

          var xmpDmBlockMatch = xmpString.match(/<rdf:Description[^>]*xmlns:xmpDM="http:\/\/ns\.adobe\.com\/xmp\/1\.0\/DynamicMedia\/"[^>]*>([\s\S]*?)<\/rdf:Description>/);



          if (xmpDmBlockMatch) {

            // xmpDM block exists - update fields within it

            var xmpDmBlockContent = xmpDmBlockMatch[1];

            var xmpDmBlockFull = xmpDmBlockMatch[0];



            for (var i = 0; i < xmpDmFields.length; i++) {

              var field = xmpDmFields[i];

              if (xmpDmBlockContent.indexOf('<' + field.tag) > -1) {

                // Field exists - replace it

                debugLog.push(field.tag + ' FOUND, replacing...');

                var beforeReplace = xmpDmBlockContent;

                xmpDmBlockContent = xmpDmBlockContent.replace(field.regex, field.value);

                if (beforeReplace === xmpDmBlockContent) {

                  debugLog.push('ERROR: ' + field.tag + ' regex did NOT match!');

                } else {

                  debugLog.push(field.tag + ' successfully replaced');

                }

              } else {

                // Field doesn't exist - append it

                debugLog.push(field.tag + ' NOT FOUND, appending...');

                xmpDmBlockContent += field.value;

              }

              debugLog.push(field.tag + ' updated');

            }



            // Replace the entire xmpDm block with updated content

            // Extract just the opening tag (everything up to first '>')

            var openingTagEnd = xmpDmBlockFull.indexOf('>') + 1;

            var openingTag = xmpDmBlockFull.substring(0, openingTagEnd);

            var newXmpDmBlock = openingTag + xmpDmBlockContent + '</rdf:Description>';

            xmpString = xmpString.replace(xmpDmBlockFull, newXmpDmBlock);



          } else {

            // xmpDm block doesn't exist - create it

            var xmpDmBlock = '<rdf:Description rdf:about="" xmlns:xmpDM="http://ns.adobe.com/xmp/1.0/DynamicMedia/">';

            for (var i = 0; i < xmpDmFields.length; i++) {

              xmpDmBlock += xmpDmFields[i].value;

              $.writeln('DEBUG SAVE: ' + xmpDmFields[i].tag + ' created');

            }

            xmpDmBlock += '</rdf:Description>';



            // Insert before closing </rdf:RDF>

            xmpString = xmpString.replace(/<\/rdf:RDF>/, xmpDmBlock + '</rdf:RDF>');

          }

        }



        item.setXMPMetadata(xmpString);

        debugLog.push('XMP metadata updated successfully');



      } catch (xmpError) {

        debugLog.push('XMP ERROR: ' + xmpError.toString());

      }



      // ========== WRITE PP EDITS JSON ==========

      // Write PP edits to original folder for ML feedback loop

      try {

        var mediaPath = item.getMediaPath();

        if (mediaPath) {

          // Extract directory and filename

          var lastSlash = mediaPath.lastIndexOf('/');

          var dirPath = mediaPath.substring(0, lastSlash);

          var filename = mediaPath.substring(lastSlash + 1);

          var filenameNoExt = filename.replace(/\.[^.]+$/, '');



          // Read existing .ingest-metadata.json (if exists)

          var iaJsonPath = dirPath + '/.ingest-metadata.json';

          var iaJsonFile = new File(iaJsonPath);

          var iaData = {};

          if (iaJsonFile.exists) {

            iaJsonFile.open('r');

            var iaJsonContent = iaJsonFile.read();

            iaJsonFile.close();

            try {

              iaData = JSON.parse(iaJsonContent);

            } catch (parseError) {

              debugLog.push('Warning: Could not parse existing IA JSON');

            }

          }



          // Build PP edits entry (matches IA format)

          var fileId = metadata.identifier ? metadata.identifier.replace(/\.[^.]+$/, '') : filenameNoExt;

          var iaEntry = iaData[fileId] || {};



          var ppEditsEntry = {};

          ppEditsEntry[fileId] = {

            // File Identification (preserve from IA)

            id: fileId,

            originalFilename: iaEntry.originalFilename || filename,

            currentFilename: filename,

            filePath: mediaPath,

            extension: iaEntry.extension || filename.substring(filename.lastIndexOf('.')),

            fileType: iaEntry.fileType || 'video',



            // Core Metadata (from PP edits)

            mainName: metadata.location + '-' + metadata.subject + (metadata.action ? '-' + metadata.action : '') + '-' + metadata.shot,

            keywords: metadata.description ? metadata.description.split(',').map(function(k) { return k.replace(/^\s+|\s+$/g, ''); }) : [],



            // Structured Components

            location: metadata.location || '',

            subject: metadata.subject || '',

            action: metadata.action || '',

            shotType: metadata.shot || '',



            // Processing State (preserve from IA)

            processedByAI: iaEntry.processedByAI || false,



            // Audit Trail

            createdAt: iaEntry.createdAt || new Date().toISOString(),

            createdBy: iaEntry.createdBy || 'unknown',

            modifiedAt: new Date().toISOString(),

            modifiedBy: 'cep-panel',

            version: '1.0.0'

          };



          // Write to .ingest-metadata-pp.json

          var ppJsonPath = dirPath + '/.ingest-metadata-pp.json';

          var ppJsonFile = new File(ppJsonPath);



          // Read existing PP edits (if any)

          var existingPpData = { _schema: '2.0' };

          if (ppJsonFile.exists) {

            ppJsonFile.open('r');

            var existingContent = ppJsonFile.read();

            ppJsonFile.close();

            try {

              existingPpData = JSON.parse(existingContent);

            } catch (e) {

              existingPpData = { _schema: '2.0' };

            }

          }



          // Merge this entry

          existingPpData[fileId] = ppEditsEntry[fileId];



          // Write back

          ppJsonFile.open('w');

          ppJsonFile.write(JSON.stringify(existingPpData, null, 2));

          ppJsonFile.close();



          debugLog.push('PP edits JSON written: ' + ppJsonPath);

        } else {

          debugLog.push('Warning: No media path, skipping PP edits JSON');

        }

      } catch (jsonError) {

        debugLog.push('PP edits JSON error: ' + jsonError.toString());

      }



      return JSON.stringify({

        success: true,

        updatedName: item.name,

        debug: debugLog

      });

    } catch (e) {

      return JSON.stringify({

        success: false,

        error: 'Failed to update metadata: ' + e.toString()

      });

    }

  }



  /**

     * Helper: Find project item by nodeId (recursive search)

     */

  function findProjectItemByNodeId(parentItem, nodeId) {

    if (parentItem.nodeId === nodeId) {

      return parentItem;

    }



    // Search children recursively

    if (parentItem.children && parentItem.children.numItems > 0) {

      for (var i = 0; i < parentItem.children.numItems; i++) {

        var found = findProjectItemByNodeId(parentItem.children[i], nodeId);

        if (found) {

          return found;

        }

      }

    }



    return null;

  }



  /**

     * Get all clips in the project (for navigation)

     */

  function getAllProjectClips() {

    try {

      var project = app.project;

      if (!project) {

        return JSON.stringify({ error: 'No active project' });

      }



      var clips = [];

      collectClipsRecursive(project.rootItem, clips);



      // Convert clips to JSON-friendly objects (ES3-compatible, no .map())

      var clipsData = [];

      for (var i = 0; i < clips.length; i++) {

        var item = clips[i];



        // Safely get metadata with try-catch per item

        var metadata = {};

        // DIAGNOSTIC: Test direct access to known Project Column names
        try {

          var projectCols = item.getProjectColumnsMetadata();

          // Try direct access to known columns
          var directAccess = [];

          if (projectCols.Tape !== undefined) {
            directAccess.push('Tape=' + projectCols.Tape);
          }

          if (projectCols.Description !== undefined) {
            directAccess.push('Desc=' + projectCols.Description);
          }

          if (projectCols.Shot !== undefined) {
            directAccess.push('Shot=' + projectCols.Shot);
          }

          // Try "Log Comment" with different variations
          if (projectCols['Log Comment'] !== undefined) {
            directAccess.push('LogComment(space)=' + projectCols['Log Comment']);
          }

          if (projectCols.LogComment !== undefined) {
            directAccess.push('LogComment(noSpace)=' + projectCols.LogComment);
          }

          if (projectCols.Comment !== undefined) {
            directAccess.push('Comment=' + projectCols.Comment);
          }

          if (projectCols['Shot Name'] !== undefined) {
            directAccess.push('ShotName(space)=' + projectCols['Shot Name']);
          }

          metadata.availableColumns = directAccess.length > 0 ? directAccess.join(' | ') : 'NO_DIRECT_ACCESS';

          $.writeln('DEBUG PROJECT COLUMNS DIRECT ACCESS: ' + metadata.availableColumns);

        } catch (colError) {

          metadata.availableColumns = 'ERROR: ' + colError.toString();

        }

        // Try reading from XMP metadata instead of Project Columns

        try {

          var xmpString = item.getXMPMetadata();

          $.writeln('DEBUG: Got XMP metadata (length: ' + xmpString.length + ')');

          // DIAGNOSTIC: Show snippet of XMP to debug console
          var xmpSnippet = xmpString.substring(0, 500);
          $.writeln('DEBUG XMP SNIPPET: ' + xmpSnippet);

          // DIAGNOSTIC: Pass XMP snippet to CEP panel diagnostics (since console doesn't work)
          metadata.xmpSnippet = xmpSnippet;

          // DIAGNOSTIC: Search for LogComment anywhere in XMP (case-insensitive)
          var logCommentIndex = xmpString.toLowerCase().indexOf('logcomment');
          if (logCommentIndex !== -1) {
            // Found it! Extract 200 chars around it for debugging
            var start = Math.max(0, logCommentIndex - 50);
            var end = Math.min(xmpString.length, logCommentIndex + 150);
            metadata.logCommentContext = xmpString.substring(start, end);
          } else {
            metadata.logCommentContext = 'NOT_FOUND_IN_XMP_STRING';
          }

          // Parse XMP for Dublin Core description

          var descMatch = xmpString.match(/<dc:description[^>]*>[\s\S]*?<rdf:li[^>]*>(.*?)<\/rdf:li>/);

          if (descMatch) {

            metadata.description = descMatch[1] || '';

            $.writeln('DEBUG: Found description in XMP: \'' + metadata.description + '\'');

          } else {

            metadata.description = '';

            $.writeln('DEBUG: No description found in XMP');

          }



          // Parse Dublin Core identifier (standard XMP field)

          var identifierMatch = xmpString.match(/<dc:identifier>(.*?)<\/dc:identifier>/);

          metadata.identifier = (identifierMatch && identifierMatch[1]) ? identifierMatch[1] : '';

          $.writeln('DEBUG: Found identifier in XMP: \'' + metadata.identifier + '\'');



          // Parse xmpDM:logComment for structured components (IA compatibility)
          // NOTE: Premiere Pro returns XMP as ELEMENTS, and IA writes lowercase 'logComment'
          var logCommentMatch = xmpString.match(/<xmpDM:logComment>(.*?)<\/xmpDM:logComment>/);
          metadata.regexAttempt = 'lowercase-c-element'; // DIAGNOSTIC
          if (!logCommentMatch) {
            // Fallback: Try capital C for CEP Panel-written XMP
            $.writeln('DEBUG: logComment (lowercase c) not found, trying capital C...');
            logCommentMatch = xmpString.match(/<xmpDM:LogComment>(.*?)<\/xmpDM:LogComment>/);
            metadata.regexAttempt = 'capital-C-element'; // DIAGNOSTIC
          }

          if (logCommentMatch) {

            var logComment = logCommentMatch[1];

            $.writeln('DEBUG: Found LogComment: \'' + logComment + '\'');

            // DIAGNOSTIC: Return raw logComment so it shows in CEP diagnostic panel
            metadata.rawLogComment = logComment;
            metadata.regexAttempt = metadata.regexAttempt + '-MATCHED'; // DIAGNOSTIC

            // Parse location=X, subject=Y, action=Z, shotType=W

            var locationMatch = logComment.match(/location=([^,]*)/);

            metadata.location = (locationMatch && locationMatch[1]) ? locationMatch[1].replace(/^\s+|\s+$/g, '') : '';



            var subjectMatch = logComment.match(/subject=([^,]*)/);

            metadata.subject = (subjectMatch && subjectMatch[1]) ? subjectMatch[1].replace(/^\s+|\s+$/g, '') : '';



            var actionMatch = logComment.match(/action=([^,]*)/);

            metadata.action = (actionMatch && actionMatch[1]) ? actionMatch[1].replace(/^\s+|\s+$/g, '') : '';



            var shotTypeMatch = logComment.match(/shotType=([^,]*)/);

            metadata.shot = (shotTypeMatch && shotTypeMatch[1]) ? shotTypeMatch[1].replace(/^\s+|\s+$/g, '') : '';

          } else {

            // Fallback: Try legacy individual XMP fields for backward compatibility

            $.writeln('DEBUG: LogComment not found, using legacy XMP fields');
            // DIAGNOSTIC: Show we didn't find it
            metadata.rawLogComment = 'NOT_FOUND_IN_XMP';
            metadata.regexAttempt = metadata.regexAttempt + '-NO_MATCH'; // DIAGNOSTIC



            var shotMatch = xmpString.match(/<xmp:Shot>(.*?)<\/xmp:Shot>/);

            metadata.shot = (shotMatch && shotMatch[1]) ? shotMatch[1] : '';



            var locationMatch = xmpString.match(/<xmp:Location>(.*?)<\/xmp:Location>/);

            metadata.location = (locationMatch && locationMatch[1]) ? locationMatch[1] : '';



            var subjectMatch = xmpString.match(/<xmp:Subject>(.*?)<\/xmp:Subject>/);

            metadata.subject = (subjectMatch && subjectMatch[1]) ? subjectMatch[1] : '';



            var actionMatch = xmpString.match(/<xmp:Action>(.*?)<\/xmp:Action>/);

            metadata.action = (actionMatch && actionMatch[1]) ? actionMatch[1] : '';

          }



          var sceneMatch = xmpString.match(/<xmp:Scene>(.*?)<\/xmp:Scene>/);

          metadata.good = (sceneMatch && sceneMatch[1]) ? sceneMatch[1] : '';



          $.writeln('DEBUG FINAL XMP VALUES for ' + item.name + ':');

          $.writeln('  identifier: \'' + metadata.identifier + '\'');

          $.writeln('  description: \'' + metadata.description + '\'');

          $.writeln('  shot: \'' + metadata.shot + '\'');

          $.writeln('  good: \'' + metadata.good + '\'');

          $.writeln('  location: \'' + metadata.location + '\'');

          $.writeln('  subject: \'' + metadata.subject + '\'');

          $.writeln('  action: \'' + metadata.action + '\'');



        } catch (xmpError) {

          $.writeln('DEBUG XMP ERROR: ' + xmpError.toString());

          // DIAGNOSTIC: Pass error to CEP panel diagnostics
          metadata.xmpSnippet = 'ERROR: ' + xmpError.toString();
          metadata.regexAttempt = 'ERROR_BEFORE_REGEX';
          metadata.rawLogComment = 'ERROR: ' + xmpError.toString();
          metadata.logCommentContext = 'ERROR: ' + xmpError.toString();

          metadata.identifier = '';

          metadata.description = '';

          metadata.shot = '';

          metadata.good = '';

          metadata.location = '';

          metadata.subject = '';

          metadata.action = '';

        }



        clipsData.push({

          nodeId: item.nodeId,

          name: item.name || '',

          treePath: item.treePath || '',

          mediaPath: item.getMediaPath() || '',

          identifier: metadata.identifier,

          description: metadata.description,

          shot: metadata.shot,

          good: metadata.good,

          location: metadata.location,

          subject: metadata.subject,

          action: metadata.action,

          // DIAGNOSTIC fields for debugging
          rawLogComment: metadata.rawLogComment || 'NOT_SET',

          regexAttempt: metadata.regexAttempt || 'NOT_SET',

          xmpSnippet: metadata.xmpSnippet || 'NOT_SET',

          logCommentContext: metadata.logCommentContext || 'NOT_SET',

          availableColumns: metadata.availableColumns || 'NOT_SET'

        });

      }



      return JSON.stringify({ clips: clipsData });

    } catch (e) {

      return JSON.stringify({

        error: 'getAllProjectClips failed',

        details: e.toString(),

        message: e.message || 'Unknown error'

      });

    }

  }



  /**

     * Helper: Recursively collect all clips from project

     */

  function collectClipsRecursive(parentItem, clips) {

    // Add current item if it's a clip

    if (parentItem.type === ProjectItemType.CLIP || parentItem.type === ProjectItemType.FILE) {

      clips.push(parentItem);

    }



    // Recurse into children

    if (parentItem.children && parentItem.children.numItems > 0) {

      for (var i = 0; i < parentItem.children.numItems; i++) {

        collectClipsRecursive(parentItem.children[i], clips);

      }

    }

  }



  /**

     * Select a specific clip in the Project Panel by nodeId

     */

  function selectClip(nodeId) {

    var project = app.project;

    if (!project) {

      return JSON.stringify({ success: false, error: 'No active project' });

    }



    var item = findProjectItemByNodeId(project.rootItem, nodeId);

    if (!item) {

      return JSON.stringify({ success: false, error: 'Clip not found' });

    }



    // Select the item in the project panel

    item.select();



    return JSON.stringify({ success: true });

  }



  /**

     * Open clip in Source Monitor

     */

  function openInSourceMonitor(nodeId) {

    var project = app.project;

    if (!project) {

      return JSON.stringify({ success: false, error: 'No active project' });

    }



    var item = findProjectItemByNodeId(project.rootItem, nodeId);

    if (!item) {

      return JSON.stringify({ success: false, error: 'Clip not found' });

    }



    try {

      // Open in Source Monitor

      app.sourceMonitor.openProjectItem(item);

      return JSON.stringify({ success: true });

    } catch (e) {

      return JSON.stringify({

        success: false,

        error: 'Failed to open in Source Monitor: ' + e.toString()

      });

    }

  }



  /**

     * Export frame at specified time from clip

     * @param {string} nodeId - Project item nodeId

     * @param {number} timeInSeconds - Time in seconds (e.g., 0.5 for half a second)

     * @returns {string} JSON with frame file path or error

     *

     * NOTE: This uses a workaround approach since PP ExtendScript doesn't have

     * a direct "export frame at time" API. We:

     * 1. Open clip in Source Monitor

     * 2. Seek to time

     * 3. Export current frame

     */

  function exportFrameAtTime(nodeId, timeInSeconds) {

    var project = app.project;

    if (!project) {

      return JSON.stringify({ success: false, error: 'No active project' });

    }



    var item = findProjectItemByNodeId(project.rootItem, nodeId);

    if (!item) {

      return JSON.stringify({ success: false, error: 'Clip not found' });

    }



    try {

      // Create a temporary folder for frame exports

      var tempFolder = Folder.temp + '/eav-cep-frames';

      var folder = new Folder(tempFolder);

      if (!folder.exists) {

        folder.create();

      }



      // Generate unique filename

      var timestamp = new Date().getTime();

      var outputPath = tempFolder + '/frame-' + nodeId + '-' + timestamp + '.jpg';



      // Method 1: Try using encoder API (PP 2018+)

      // This is the most reliable method if available

      if (app.encoder && typeof app.encoder.encodeFile === 'function') {

        // Convert time to ticks (254016000000 ticks per second)

        var ticksPerSecond = 254016000000;

        var inPoint = Math.floor(timeInSeconds * ticksPerSecond);

        var outPoint = inPoint + 1; // Single frame



        // Use JPEG export preset

        var success = app.encoder.encodeFile(

          item.getMediaPath(),

          outputPath,

          app.encoder.ENCODE_IN_TO_OUT,

          [item],

          inPoint,

          outPoint

        );



        if (success) {

          return JSON.stringify({

            success: true,

            framePath: outputPath,

            timeInSeconds: timeInSeconds,

            method: 'encoder API'

          });

        }

      }



      // Method 2: Fallback - Open in Source Monitor and export current frame

      // This is less reliable but works across more PP versions

      app.sourceMonitor.openProjectItem(item);



      // Seek to time (in ticks)

      var ticksPerSecond = 254016000000;

      var timeInTicks = Math.floor(timeInSeconds * ticksPerSecond);

      app.sourceMonitor.setPosition(timeInTicks);



      // Export current frame (if method exists)

      // Note: exportFramePNG may not exist in all PP versions

      if (typeof item.exportFramePNG === 'function') {

        var success = item.exportFramePNG(timeInTicks, outputPath);



        if (success) {

          return JSON.stringify({

            success: true,

            framePath: outputPath,

            timeInSeconds: timeInSeconds,

            method: 'exportFramePNG'

          });

        }

      }



      // Method 3: Ultimate fallback - return media path

      // CEP panel will handle frame extraction client-side if needed

      return JSON.stringify({

        success: false,

        error: 'Frame export API not available in this PP version',

        fallback: 'use_media_path',

        mediaPath: item.getMediaPath(),

        timeInSeconds: timeInSeconds

      });



    } catch (e) {

      return JSON.stringify({

        success: false,

        error: 'Failed to export frame: ' + e.toString(),

        details: 'Time: ' + timeInSeconds + 's'

      });

    }

  }



  /**

     * Parse structured naming from original filename

     * Expects format: {8-digit-id}-restofname.ext

     */

  function parseStructuredNaming(filename) {

    // Remove extension

    var nameWithoutExt = filename.replace(/\.[^.]+$/, '');



    // Try to extract 8-digit ID

    var idMatch = nameWithoutExt.match(/^(\d{8})/);

    var id = idMatch ? idMatch[1] : '';



    return JSON.stringify({

      id: id,

      originalFilename: filename

    });

  }



  // Public API

  return {

    getSelectedClips: getSelectedClips,

    updateClipMetadata: updateClipMetadata,

    getAllProjectClips: getAllProjectClips,

    selectClip: selectClip,

    openInSourceMonitor: openInSourceMonitor,

    exportFrameAtTime: exportFrameAtTime,

    parseStructuredNaming: parseStructuredNaming

  };

})();



// Make functions available to CEP panel

EAVIngest;
</file>

</files>
